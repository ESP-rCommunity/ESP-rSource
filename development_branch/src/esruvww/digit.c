/*
 * read and display ww images in a window.
 * images can be the following:
 *  -ww = file uses ascii ww commands format (as generated by
 *        esp-r applications.
 *  -vp = file uses the (binary) pic format generated by viewer.
 *  -ex = file uses ww exrep format converted from various screen
 *        formats by the application conv.
 */
#include <stdio.h>
#include "wwinfo.h"
#include "pic2bit.h"

FILE *wwc;
#define STOP		0	/* index in menu */
#define		OK 1
#define	MOVE_ABS	0
#define	DRAW_ABS	1
int xorig=0, yorig=0;

#define 	HEIGHT(b)      (abs(b.b_bottom-b.b_top+1))
#define 	WIDTH(b)       (abs(b.b_right-b.b_left+1))
int	minx=0, maxx=0, miny=0, maxy=0;
#define	MINX(x)	((x<minx)?x:minx)
#define MINY(y) ((y<miny)?y:miny)
#define MAXX(x) ((x>maxx)?x:maxx)
#define MAXY(y) ((y>maxy)?y:maxy)

extern    char    *malloc();
poly *read_pic();

/* read viewer picture file */
/*
	INTERNAL DATA FORMAT

	poly_data->(line)->[start(x,y)]->[end(x,y)]	
		      |
		   (line)->[start(x,y)]->[end(x,y)]
		      |
		   (line)->[start(x,y)]->[end(x,y)]
		      |
		   (line)->[start(x,y)]->[end(x,y)]
*/
read_viewer_pic(fp)	/* read viewer picture file (binary) */
FILE	*fp;
{
float picture_dx, picture_dy;
float mid_point[3], focus_point[3], eye_point[3];
int projection,t,namset,i;
float view_angle,fl,ef,xy,dummy;
char nam[30];
float sx,sy,ex,ey;
poly	*line;
pair	*start_point,*end_point;

	i = 0;

	/* read header */
	fread(&dummy,sizeof(dummy),1,fp);	/* dummy read */
	fread(&picture_dx,sizeof(float),1,fp);
	fread(&picture_dy,sizeof(float),1,fp);
	fread(mid_point,sizeof(float),3,fp);
	fread(focus_point,sizeof(float),3,fp);
	fread(eye_point,sizeof(float),3,fp);
	fread(&projection,sizeof(int),1,fp);
	fread(&view_angle,sizeof(float),1,fp);
	fread(&t,sizeof(t),1,fp);
	fread(&fl,sizeof(fl),1,fp);
	fread(&ef,sizeof(ef),1,fp);
	fread(nam,sizeof(char),30,fp);
	fread(&namset,sizeof(int),1,fp);
	fread(&xy,sizeof(xy),1,fp);

	line = poly_data = (poly*)malloc(sizeof(poly));

	while(!feof(fp)){
		line->number = ++i;
		line->links = 2; /* number of points in polygon/line */
		line->colour_index = 1; /* colour necessary for scodl format */
		start_point=(pair*)malloc(sizeof(pair));
		end_point  =(pair*)malloc(sizeof(pair));
		start_point->next = end_point;

		line->points = start_point;
/* 
 * items on the line from viewer plottr.f are CL,SX,SY,CO,A,B,IO
 * where SX,SY are start point, A,B end point, IO pen position
*/
	        fread(&dummy,sizeof(dummy),1,fp); /* dummy reads before each line */
	        fread(&dummy,sizeof(dummy),1,fp);
		fread(&dummy,sizeof(dummy),1,fp); /* dummy read CL */
		fread(&sx,sizeof(float),1,fp);
		fread(&sy,sizeof(float),1,fp);
		fread(&dummy,sizeof(dummy),1,fp); /* dummy read CO */
		fread(&ex,sizeof(float),1,fp);
		fread(&ey,sizeof(float),1,fp);
		fread(&i,sizeof(int),1,fp);

/*	fprintf(stderr,"line %7.2f %7.2f %7.2f %7.2f %d \n",sx,sy,ex,ey,i);  */

		if(i == -1)break;

		/* determine boundary points */
		MagX((int)sx);MagX((int)ex);
		MagY((int)sy);MagY((int)ey);

		start_point->x = (int)sx;
		start_point->y = (int)sy;
		end_point->x   = (int)ex;
		end_point->y   = (int)ey;
		line->next = (poly*)malloc(sizeof(poly));
		line = line->next;
	}
	line = poly_data;
}

pic_bitmap(filename,canvas,bx)
bitmap *canvas;
box  bx;
char *filename;
{
	if((poly_data=read_pic(filename))!=NULL)
	{
		write_bitmap(poly_data, canvas, bx);
	}else {
		fprintf(stderr,"Failed to read `%s'\n",filename);
        }
}

poly*
read_pic(filename)
char *filename;
{
FILE	*fp;
	if(filename==NULL) return((poly*)NULL);
	fp = fopen(filename,"rb");
	read_viewer_pic(fp);	
	return(poly_data);
}

float view_scale = 1.0;
int y_correct = 1;
int x_correct = 1;

write_bitmap(poly_data, canvas, bx)
poly *poly_data;
box  bx;
bitmap *canvas;
{
/*
 * L & H is length & height in from 1000x1000 pic_file reading,
 * l & h is length & height of image box.
 */
int	L,H,l,h;
int border = 5;

	L = abs(maxx - minx);
	H = abs(maxy - miny);
	xorig=abs(minx);
	yorig=abs(miny);
/* 	fprintf(stderr,"wb xorg %d yorg %d L %d H %d \n",xorig,yorig,L,H);  */

	l=WIDTH(bx);
	h=HEIGHT(bx); 
	if(l<h)			/* keep aspect ratio */
	{
		h=H*l/L;
		view_scale = l/(float)L;
	}else
	{
		l=L*h/H;
		view_scale = h/(float)H;
	}

	y_correct = HEIGHT(bx) + bx.b_top;  /* add in upper pixel position of bx */
	x_correct = bx.b_left;  	    /* add in left pixel position of bx */
	xorig+=border;
	yorig+=(int)(border/2);
	
	bmxbox(canvas,bx,BMCLEARALL);	/* clear canvas */
	draw_picture(poly_data,canvas,bx);
}


draw_picture(poly_data,canvas,bx)
poly *poly_data;
bitmap *canvas;
box  bx;
{
poly *pp = poly_data;

	if(canvas==NULL) return;
	ddbm = canvas;
	dd->d_line = WWCOPY;
	while(pp!=NULL)
	{
		draw_polygon(pp);
		pp=pp->next;
	}
}

draw_polygon(polygon)
poly	*polygon;
{
pair	*point;
register int i=0;

	if (polygon == NULL) return;
	point = polygon->points;
	if(polygon->links == 2)	/* line */
	{
		ExrepLine(point->x,point->y,MOVE_ABS);
		ExrepLine(point->next->x, point->next->y,DRAW_ABS);
	}else
	if (polygon->links>2) 	/* polygon */
	{
		/* move to first point of polygon */
		ExrepLine(point->x,point->y,MOVE_ABS);
		for(i=1;i<polygon->links;i++)
		{
			if(point!=NULL)
				if(point->next!=NULL)
				{
					point = point->next;
					ExrepLine(point->x,point->y,DRAW_ABS);
				}
		}
		/* close the polygon */
		ExrepLine(polygon->points->x,polygon->points->y,DRAW_ABS);
	}
}

ExrepLine(x,y,flag)	/* draw lines on ddbm */
int	x,y,flag;
{
	x+=xorig;
	y+=yorig;
	x=x_correct+(int)(view_scale*x);
	y=y_correct-(int)(view_scale*y);
	switch(flag)
	{
		case	MOVE_ABS: line(x,y,LNMOVEABS); break;
		case	DRAW_ABS: line(x,y,LNDRAWABS); break;
	}
}

MagX(x)
int x;
{
	minx=MINX(x);
	maxx=MAXX(x);
}
MagY(y)
int y;
{
	miny=MINY(y);
	maxy=MAXY(y);
}


wwc_read_(name,flag,len)
char *name;
long int *flag;
int len;	/* string length from fortran */
{
 int iexp, itm, ier;
 int ilen, count;
 char outstr[124];
 char word[72];

 long int menu_char,gw,gh,cl,cr,ct,cb,vl,vr,vt,vb; /* for variables read in */
 float xmn, xmx, ymn, ymx, xsc, ysc, sca, xadd, yadd;
 float fx,fy,ux,uy;
 float ladd, lscale, badd, bscale;
 long int  offl,offb,offt,offr,mode,side;
 long int x1, y1, x2, y2, ipdis, ipos;	
 long int x, y, sym, size, loff, boff;	
 long int linep,updown;

/* 
 * Terminate at fortran length, find actual string length
 * and then reterminate.
 */
  f_to_c_l(name,&len,&ilen);
  if ( ilen < len ) name[ilen] = '\0';
  if ((wwc = fopen(name,"r"))==NULL) {
   fprintf(stderr,"could not open wwc file %s\n",name);
   return;
  }
  fprintf(stderr,"file is %s\n",name);
  win3dclr_();
  do {	/* Read a line from file, skipping & stripping comments */
    iexp = 99; itm = 0; ier = 0;
    cstripc(wwc,outstr,&iexp,&itm,"wwc problem",&ier);

    count = sscanf(outstr,"%s",word);
    iexp = 99; itm = 0; ier = 0;
    if (strncmp(word, "*start_set", 10) == 0) {
    } else if (strncmp(word, "*end_set", 8) == 0) {
    } else if (strncmp(word, "*end_wwc", 8) == 0) {
        fprintf(stderr,"finished set of commands\n");
        fclose(wwc);
        return;
    } else if (strncmp(word, "*axiscale", 9) == 0) {
        iexp = 11;
        cstripc(wwc,outstr,&iexp,&itm,"axiscale cmd",&ier);
        sscanf(outstr,"%d%d%f%f%f%f%f%f%f%f%f",
          &gw,&gh,&xmn,&xmx,&ymn,&ymx,&xsc,&ysc,&sca,&xadd,&yadd);
        axiscale_(&gw,&gh,&xmn,&xmx,&ymn,&ymx,&xsc,&ysc,&sca,&xadd,&yadd);
    } else if (strncmp(word, "*edline", 7) == 0) {
        iexp = 5;
        cstripc(wwc,outstr,&iexp,&itm,"edline cmd",&ier);
        sscanf(outstr,"%d%d%d%d%d",&x1,&y1,&x2,&y2,&ipdis);
        edline_(&x1,&y1,&x2,&y2,&ipdis);
    } else if (strncmp(word, "*esymbol", 8) == 0) {
        iexp = 4;
        cstripc(wwc,outstr,&iexp,&itm,"esymbol cmd",&ier);
        sscanf(outstr,"%d%d%d%d",&x,&y,&sym,&size);
        esymbol_(&x,&y,&sym,&size);
    } else if (strncmp(word, "*etlabel", 8) == 0) {
        cstripc(wwc,outstr,&iexp,&itm,"etlabel cmd",&ier);
        sscanf(outstr,"%f%f%d%d%",&fx,&fy,&ipos,&size);
        cstripc(wwc,outstr,&iexp,&itm,"etlabel msg",&ier);
        etlabel_(outstr,&fx,&fy,&ipos,&size,strlen(outstr));
    } else if (strncmp(word, "*etplot", 7) == 0) {
        iexp = 4;
        cstripc(wwc,outstr,&iexp,&itm,"etplot cmd",&ier);
        sscanf(outstr,"%f%f%d%d%",&ux,&uy,&updown,&sym);
        etplot_(&ux,&uy,&updown,&sym);
    } else if (strncmp(word, "*horaxis", 8) == 0) {
        cstripc(wwc,outstr,&iexp,&itm,"horaxis cmd",&ier);
        sscanf(outstr,"%f%f%d%d%d%f%f%d%",&xmn,&xmx,&offl,&offr,&offb,&xadd,&sca,&mode);
        cstripc(wwc,outstr,&iexp,&itm,"horaxis msg",&ier);
        horaxis_(&xmn,&xmx,&offl,&offr,&offb,&xadd,&sca,&mode,outstr,strlen(outstr));
    } else if (strncmp(word, "*linescale", 10) == 0) {
        iexp = 6;
        cstripc(wwc,outstr,&iexp,&itm,"linescale cmd",&ier);
        sscanf(outstr,"%d%f%f%d%f%f",&loff,&ladd,&lscale,&boff,&badd,&bscale);
        linescale_(&loff,&ladd,&lscale,&boff,&badd,&bscale);
    } else if (strncmp(word, "*viewtext", 9) == 0) {
        cstripc(wwc,outstr,&iexp,&itm,"viewtext cmd",&ier);
        sscanf(outstr,"%d%d%d%",&linep,&side,&size);
        cstripc(wwc,outstr,&iexp,&itm,"viewtext msg",&ier);
        viewtext_(outstr,&linep,&side,&size,strlen(outstr));
    } else if (strncmp(word, "*vrtaxis", 8) == 0) {
        cstripc(wwc,outstr,&iexp,&itm,"vrtaxis cmd",&ier);
        sscanf(outstr,"%f%f%d%d%d%f%f%d%d%",&ymn,&ymx,&offl,&offb,&offt,&yadd,&sca,&mode,&side);
        cstripc(wwc,outstr,&iexp,&itm,"vrtaxis msg",&ier);
        vrtaxis_(&ymn,&ymx,&offl,&offb,&offt,&yadd,&sca,&mode,&side,outstr,strlen(outstr));
    } else if (strncmp(word, "*win3d", 6) == 0) {
        iexp = 11;
        cstripc(wwc,outstr,&iexp,&itm,"win3d cmd",&ier);
        sscanf(outstr,"%d%d%d%d%d%d%d%d%d%d%d",
          &menu_char,&cl,&cr,&ct,&cb,&vl,&vr,&vt,&vb,&gw,&gh);
        if (*flag == 1) menu_char = 1;   /* reset if not displaying in esp-r */
        win3d_(&menu_char,&cl,&cr,&ct,&cb,&vl,&vr,&vt,&vb,&gw,&gh);
    }

  } while ( ier == 0);
  fclose(wwc);
}   /* wwc_read */



main(argc,argv)char **argv;{
  int what,style,in,stop,i,type;
  exrep ex;
  bitmap *bm;
  window *d_win;
  box offb, refr, size,img_size;
  char *inf  = "UNKNOWN";  /* input file string */
  int std_fnt = 1;
  int ulx = 120;	/* default initial window position */
  int uly = 80;
  int w_size = 380;
  int t_mode = 9;
  long int flag = 1;
  int noxget = 0;	/* 0=use wwxget, 1= refresh mode */
/*
 * Command line if pipe then open on file unit 0, if more than
 * one argument check to see if "-vp" (for viewer pic format).
 */
  if(argc == 1 ) {                 /* no commands to put in defaults */
     printf(" No arguments - a_exr aborting.... \n");
     exit(1);
  } else if (argc > 1 )  {
	for (i = 1; i < argc; i++) {
		if (strncmp(argv[i], "-help", 5) == 0) {
			printf(" \n");
			printf(" This displays ww exrep format images and viewer pic command files. \n");
			printf(" Use: [-vp|-ex|-ww] <file> [-g <X> <Y>] \n");
			printf(" \n");
			printf("   where options are:\n") ;
			printf("     -ww = file uses ascii ww commands format\n");
			printf("     -vp = file uses viewer pic format\n");
			printf("     -ex = file uses ww exrep format \n");
			printf("     -g  = X Y pixels of upper left corner \n");
			printf(" \n");
			printf(" -help :this help message.\n");
			printf(" \n");
			exit(1);
		}
		if (strncmp(argv[i], "-ex", 3) == 0) {	/* ww exrep image */
			type = 0;
			inf = argv[++i];
			in = open(inf,0);
		}
		if (strncmp(argv[i], "-vp", 3) == 0) {	/* viewer binary pic commands */
			type = 1;
			inf = argv[++i];
		}
		if (strncmp(argv[i], "-ww", 3) == 0) {	/* ww ascii commands */
			type = 2;
			inf = argv[++i];
		}
		if (strncmp(argv[i], "-g", 2) == 0) {	/* upper left pos of window */
			ulx = atoi(argv[++i]);
			uly = atoi(argv[++i]);
		}
	}
  }
/*
 * If ww ascii commands, call wwlib.c (winit) and then proceed
 * to read/draw the commands.
 */
  if (type == 2) {
        d_win = 0;
	sizeint_(&w_size,&ulx,&uly);
	winint_(&t_mode,inf,strlen(inf)); 
	bm = ddwin->w_bm;
	winfnt_(&std_fnt);
	offb.b_left = ddbm->bm_box.b_left;
	offb.b_bottom = ddbm->bm_box.b_bottom;
	offb.b_right = offb.b_left + 6 * ddfont->f_width;
	offb.b_top = offb.b_bottom - 2 * ddfont->f_height;
	bmbox(offb,BMEDGES|BMCLEAR);
	ftxprint(offb.b_left+6,offb.b_bottom-6,"STOP",4,WWXOR,ddfont,ddbm,0);

	wwc_read_(inf,&flag,strlen(inf));
  } else {

    if (wwxget(boxbuild(10,10,120,60),2,inf,0)==0) exit(1);
    ftprint(ddbm->bm_box," Image Display",0);  
    size = boxzoom(ddbm->bm_box,-5);
    offb.b_left = size.b_left;
    offb.b_bottom = size.b_bottom;
    offb.b_right = offb.b_left + (6 * ddfont->f_width);
    offb.b_top = offb.b_bottom - (2 * ddfont->f_height);
    bmbox(offb,BMEDGES|BMCLEAR);
    ftxprint(offb.b_left+6,offb.b_bottom-6,"Stop",4,WWXOR,ddfont,ddbm,0);

    refr.b_right = size.b_right;
    refr.b_left = refr.b_right - (8 * ddfont->f_width);
    refr.b_bottom = size.b_bottom;
    refr.b_top = refr.b_bottom - (2 * ddfont->f_height);
    bmbox(refr,BMEDGES|BMCLEAR);
    ftxprint(refr.b_left+6,refr.b_bottom-6,"Refresh",7,WWXOR,ddfont,ddbm,0);

    refresh:
    d_win = 0;
    if (type == 0) {
	what = exread(in,&style,&ex);
	switch(what){
	    case EXBITMAP:
		bm = ex.ex_bitmap;
		break;
	    case WWERROR:
		what = EXBITMAP;
		fprintf(stderr,"exrep read error eof\n");
		break;
	    default:
		wwpanic("what?");
	}
	if(bm!=0){
		if( noxget==0) d_win = wwxget(boxbuild(ulx,uly,ulx+bm->bm_box.b_right,uly+bm->bm_box.b_bottom),
			2,inf,0);
		bmxcopy(bm,bm->bm_box,d_win->w_bm,d_win->w_bm->bm_box,WWCOPY);
		bmfree(bm);
	}
    } else if (type == 1) {
	if( noxget==0){
		d_win = wwxget(boxbuild(ulx,uly,ulx+300,uly+200),2,inf,0);
		bm = d_win->w_bm;
		img_size = boxzoom(bm->bm_box,-20);
	}
	pic_bitmap(inf,bm,img_size);
    }
  }
  if( noxget==1) noxget=0;	/* reset flag after refresh has been done */
  bm = 0;
  ipset(IPON);
  stop = FALSE;
  while(!stop){
	ipwait();
	if(boxinside(offb,dd->d_x,dd->d_y)) {
		switch(dd->d_buttons){
		    case ITEMBUTTON:
		    case MENUBUTTON:
		    case SHOWBUTTON:
				stop++;
				break;
		    default:
				xxneutral();
				break;
		}
	} else if(boxinside(refr,dd->d_x,dd->d_y)) {
		switch(dd->d_buttons){
		    case ITEMBUTTON:
		    case MENUBUTTON:
		    case SHOWBUTTON:
				if(type != 2) {
					noxget = 1;
					bm = d_win->w_bm;
					goto refresh;
				}
				break;
		    default:
				xxneutral();
				break;
		}
	} else if(dd->d_event==IPKEY){
		wwnoise();	/* ignore it */
	}
  };
  ipset(IPOFF);
}

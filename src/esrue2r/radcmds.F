C This file is part of the ESP-r system.
C Copyright Energy Systems Research Unit, University of
C Strathclyde, Glasgow Scotland, 2001.

C ESP-r is free software.  You can redistribute it and/or
C modify it under the terms of the GNU General Public
C License as published by the Free Software Foundation 
C (version 2 orlater).

C ESP-r is distributed in the hope that it will be useful
C but WITHOUT ANY WARRANTY; without even the implied
C warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
C PURPOSE. See the GNU General Public License for more
C details.

C You should have received a copy of the GNU General Public
C License along with ESP-r. If not, write to the Free
C Software Foundation, Inc., 59 Temple Place, Suite 330,
C Boston, MA 02111-1307 USA.

C This file contains routines which execute Radiance commands.
C  autorad   - executes the Radiance commands for a particular command 
C              line act
C  simscene  - simulates daylight coefficients and coupling (called from bps)
C  settime   - user choice of standard times for sky generation
C  touchrif  - generates an options file based on information 
C              generated by rad -t after removing current octree.
C  defview   - generates a new default view.
C  genimage  - generates image(s) to screen or file.
C  dispimage - displays an image file to screen.
C  getglr    - recovers view information and runs glare calculation.
C  getdf     - runs daylight factor calculation.
C  getlux    - runs grid of illuminance calculation.

C Useful block of code:
C          if(pathtype(1:9).eq.'radinhome')then
C          elseif(pathtype(1:8).eq.'radincfg')then
C          elseif(pathtype(1:8).eq.'radinrad')then
C          endif

C ********************** autorad **********************
C autorad options:
C  'Create' - depending on scene purpose create Radiance model
C  else simulate the scene by calling simscene

      SUBROUTINE autorad
#include "building.h"
#include "site.h"
#include "e2r_common.h"
      
      integer lnblnk  ! function definition

      COMMON/FILEP/IFIL

      character outs*124,tfile*72

      LOGICAL fict,XST,OK,DOK

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='autorad'  ! set for subroutine

      ITA2=IFIL+7
      ITA3=IFIL+10

C Create a default scene based on current information - ask 
C for additional info if necessary.
      if (cmdact(1:6).ne.'Create') then
        call simscene

C Quit.
        call tstamp('>','Finish automatic visual analysis')
        CALL EPAGEND
        STOP
      endif


C For each scene purpose generate typical sky file.
C Process daylight coefficients seperately as sky file is artificial.
      if (SCENEPURP(ISCENE)(1:8).eq.'Day_coef') then

C Search for existing 'sky' file. (If found delete)
        write(tfile,'(2a)')runpath(1:lnblnk(runpath)),
     &                     rskyfil(1:lnblnk(rskyfil))
        INQUIRE (FILE=tfile,EXIST=XST)
        if(XST)then
          call FPOPEN(ITA3,ISTAT,1,0,tfile)
          call EFDELET(ITA3,ISTAT)
        endif
        call FPOPEN(ITA3,ISTAT,1,2,tfile)
        write(ITA3,'(a)') '# sky patch: 0'
        write(ITA3,'(a)') '  '
        write(ITA3,'(a)') 'void  light  patch_light'
        write(ITA3,'(a)') '0 '
        write(ITA3,'(a)') '0 '
        write(ITA3,'(a)') '3  1000000  1000000  1000000'
        write(ITA3,'(a)') '  '
        write(ITA3,'(a)')'patch_light source patch'
        write(ITA3,'(a)')'0'
        write(ITA3,'(a)')'0'
        write(ITA3,'(a)') '4  0.  0.  1.  13.39'
        call ERPFREE(ITA3,ISTAT)
        skydone=.true.
      else

C Generate sky command use a sun for all skys except for daylight factors.
C Day_lux is similar to Day_fact except it returns lux values rather than
C daylight factors for a CIE sky. Purpose Illum uses the current sky.
        if (SCENEPURP(ISCENE)(1:8).eq.'External'.or.
     &      SCENEPURP(ISCENE)(1:8).eq.'Internal'.or.
     &      SCENEPURP(ISCENE)(1:5).eq.'Glare'.or.
     &      SCENEPURP(ISCENE)(1:5).eq.'Illum') then
          call settime(IRM,IRD,XRT)
          write(outs,'(a,2i3,f6.2,a,f5.2,2(a,f7.1),a)')'gensky',IRM,IRD,
     &      XRT,' +s -g ',rgrfl,' -a ',sitelat,' -o ',-sitelongdif,
     &      ' -m 0.0'
        elseif (SCENEPURP(ISCENE)(1:8).eq.'Day_fact') then
          write(outs,'(a,f5.2,2(a,f7.1),a)') 'gensky 6 20 12.0 -c -g ',
     &      rgrfl,' -a ',sitelat,' -o ',-sitelongdif,' -m 0.0'
        elseif (SCENEPURP(ISCENE)(1:7).eq.'Day_lux') then
          write(outs,'(a,f5.2,2(a,f7.1),a)') 'gensky 6 20 12.0 -c -g ',
     &      rgrfl,' -a ',sitelat,' -o ',-sitelongdif,' -m 0.0'
        elseif (SCENEPURP(ISCENE)(1:8).eq.'Coupling') then

C gendaylit -ang 60 0 -L QDIRILL QDIFILL
          write(outs,'(a,f5.2)')
     &                     'gendaylit -ang 60 0 -L 805 100 -g ',rgrfl

        elseif (SCENEPURP(ISCENE)(1:7).eq.'Sun_pos') then

C Pick start and end time.
        endif

C Now call Radiance with command stored in variable 'outs'.
        call wrtsky(outs)
        call RRSKY(ITA2,ga,IER)
        if (SCENEPURP(ISCENE)(1:8).eq.'External') then
          call RADPAR('av',ga)
        elseif (SCENEPURP(ISCENE)(1:8).eq.'Internal') then
          xga=ga/10.
          call RADPAR('av',xga)
        endif
      endif

C Create inside and outside files, first open databases.
      call module_opendb(ier)
      ftr=0.92
      fict=.false.
      call mkriofil(ftr,fict,'s',IER)
      IFC=3
      call mkrif(ita2,RIFNAME(ISCENE),IFC,0,ier)
      if (NBSRIF(ISCENE).eq.1) then
        call mkrif(ita2,LBSRIF(ISCENE),IFC,1,ier)
      endif

C Update rcf file and configuration file.
      ICHK=3
      call RADCFGOUT(ICHK)

C Generate new octree.
      call touchrif(RIFNAME(ISCENE))
      if (NBSRIF(ISCENE).gt.0) then
        call touchrif(LBSRIF(ISCENE))
      endif

C If scene purpose is coupling, daylight coefficients then return.
      if (SCENEPURP(ISCENE)(1:8).eq.'Coupling') then
        return
      elseif (SCENEPURP(ISCENE)(1:8).eq.'Day_coef') then
        return
      endif

C Continue and run radiance simulation?
      dok=.true.
      helptopic='e2r_proceed_with_sim'
      call gethelptext(helpinsub,helptopic,nbhelp)
      call ASKOK('Scene description is now complete.',
     &           'Proceed with simulation?',OK,dok,nbhelp)
      if (OK) then
        if (SCENEPURP(ISCENE)(1:8).eq.'External'.or.
     &      SCENEPURP(ISCENE)(1:8).eq.'Internal') then

C Generate default view information and then the image.
          call defview
          call genimage(1)
        elseif (SCENEPURP(ISCENE)(1:5).eq.'Glare') then

C Generate <<? default view information ?>> and then the image.
          call defview
          call genimage(2)
          call getglr
          call dispimage(2)
        elseif (SCENEPURP(ISCENE)(1:8).eq.'Day_fact') then

C Calculate the daylight factors and then diplay them via dfgridlbl.
          call getdf
          call DFGRIDLBL('d')
        elseif (SCENEPURP(ISCENE)(1:7).eq.'Day_lux'.or.
     &          SCENEPURP(ISCENE)(1:5).eq.'Illum') then

C Calculate the illuminance at grid points and then diplay via dfgridlbl.
          call getlux
          call DFGRIDLBL('l')
        endif
      endif

      return
      end

C ********************** simscene **********************
C simscene simulates daylight coefficients and coupling (called from bps)

      SUBROUTINE simscene
#include "building.h"
#include "model.h"
#include "e2r_common.h"
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      COMMON/FILEP/IFIL

      character outs*124,doit*124,doitl*256,tfile*72
      character QT*1
      character*72 LTMPFL,LTMPFA,rn

C There are 8 patch zones in the sky dome.
      dimension npz(8),pzalt(8),pzazim(8),solid(8)

      LOGICAL XST,unixok

      data npz/30,60,84,108,126,138,144,145/
      data pzalt/6.,18.,30.,42.,54.,66.,78.,90./
      data pzazim/12.,12.,15.,15.,20.,30.,60.,0./
      data solid/13.39,13.39,13.39,13.39,13.39,13.39,13.39,13.39/

      QT=CHAR(39)
      ITA1=IFIL+6
      ITA2=IFIL+7
      ITA3=IFIL+10
      call isunix(unixok)

C Simulate scene as defined by aim argument.
      if (SCENEPURP(ISCENE)(1:8).eq.'Coupling') then

C Read from transfer file defined as the argument for -act from
C the users home folder.
        if(unixok)then
          write(doit,'(6a)') 'cp ',upath(1:lnblnk(upath)),'/',
     &               cmdact(1:lnblnk(cmdact)),'  ',runpath(1:lnrp)
        else
          write(doit,'(6a)') 'copy /y ',upath(1:lnblnk(upath)),'/',
     &               cmdact(1:lnblnk(cmdact)),'  ',runpath(1:lnrp)
        endif
        call runit(doit,'-')
        ier=0
        write (LTMPFL,'(2a)') runpath(1:lnrp),cmdact(1:lnblnk(cmdact))
        call FPOPEN(ITA1,ISTAT,1,1,LTMPFL)
        if (ier.ne.0) then 
          call usrmsg('Cannot open transfer file:',cmdact,'F')
          return
        endif
        CALL STRIPC(ITA1,OUTS,0,ND,0,'transfer file',IER)
        if (ier.ne.0) then 
          call usrmsg('Cannot read transfer file:',cmdact,'F')
          return
        endif
        K=0
        call EGETWR(OUTS,K,RSALT,0.,90.,'F','Solar alt',IER)
        call EGETWR(OUTS,K,RSAZI,-180.,180.,'W','Sol azi',IER)
        call EGETWR(OUTS,K,QDIR,0.,1250.,'W','Dir solar',IER)
        call EGETWR(OUTS,K,QDIF,0.,1250.,'W','Diff solar',IER)
        call EGETWI(OUTS,K,IBLNDS,0,1,'W','Blinds state',IER)

C Check solar position and radiation.
        QDIRH=QDIR*esind(RSALT/57.296)

C Create sky command and sky.
        if (RSALT.gt.5.0) then
          write(outs,'(a,2f7.1,a,2f7.1,a,f5.2)')'gendaylit -ang ',RSALT,
     &                         RSAZI,' -W ',QDIR,QDIF,' -g ',rgrfl
        else
          if (QDIR.gt.0.0) then
            write(outs,'(a,2f7.1,2(a,f7.1),a,f5.2)')'gensky -ang ',
     &                RSALT,RSAZI,' -B ',QDIF,' -R ',QDIRH,' -g ',rgrfl
          else
            write(outs,'(a,2f7.1,a,f7.1,a,f5.2)')'gensky -ang ',RSALT,
     &                                RSAZI,' -c -B ',QDIF,' -g ',rgrfl
          endif
        endif
        call wrtsky(outs)

C Recreate octree, setting rtrace options, and run rtrace.
        if (IBLNDS.ne.0.and.NBSRIF(ISCENE).eq.0) then

C Error can't simulate switched blinds.
          call usrmsg('Cannot simulate switched blinds.','  ','F')
        endif
        if (IBLNDS.eq.0) then
          rn=RIFNAME(ISCENE)
        else
          rn=LBSRIF(ISCENE)
        endif

C Rebuild.
        call touchrif(rn)

C Run rtrace. << ?? what about pathtype?? >>
        write(doitl,'(4a,1x,9a)') 'cd ',runpath(1:lnrp),
     &      '; rtrace -ov -I -h @',
     &      optnfil(1:lnblnk(optnfil)),octfil(1:lnblnk(octfil)),
     &       ' < ',LDFGRID(ISCENE)(1:lnblnk(LDFGRID(ISCENE))),
     &       ' | rcalc -e ',QT,
     &       '$1=179*(0.265*$1+0.670*$2+0.065*$3)',QT,' >> ',
     &      cmdact(1:lnblnk(cmdact))
        call runit(doitl,'-')

C Copy transfer file back to users homedir (bps is expecting it to be there).
        call isunix(unixok)
        if(unixok)then
          write(doit,'(5a)') 'cp ',runpath(1:lnrp),
     &      cmdact(1:lnblnk(cmdact)),'  ',upath(1:lnblnk(upath))
        else
          write(doit,'(5a)') 'copy /y ',runpath(1:lnrp),
     &      cmdact(1:lnblnk(cmdact)),'  ',upath(1:lnblnk(upath))
        endif
        call runit(doit,'-')

C Daylight coefficients.
      elseif (SCENEPURP(ISCENE)(1:8).eq.'Day_coef') then

C Do for all blind states.
        IBLND=0
 1234   do 123 IPTCH=1,145

C Search for existing 'sky' file. (If found delete)
          write(tfile,'(a,a)')runpath(1:lnrp),
     &                        rskyfil(1:lnblnk(rskyfil))
          INQUIRE (FILE=tfile,EXIST=XST)
          if(XST)then
            call FPOPEN(ITA3,ISTAT,1,0,tfile)
            call EFDELET(ITA3,ISTAT)
          endif
          call FPOPEN(ITA3,ISTAT,1,2,tfile)
          write(ITA3,'(a,i4)') '# sky patch: ',IPTCH
          write(ITA3,'(a)') '  '
          write(ITA3,'(a)') 'void  light  patch_light'
          write(ITA3,'(a)') '0 '
          write(ITA3,'(a)') '0 '
          write(ITA3,'(a)') '3  1000000  1000000  1000000'
          write(ITA3,'(a)') '  '

C Calculate patch direction vector (location).
          if(IPTCH.ge.1.and.IPTCH.le.30) nzone = 1
          if(IPTCH.ge.31.and.IPTCH.le.60) nzone = 2
          if(IPTCH.ge.61.and.IPTCH.le.84) nzone = 3
          if(IPTCH.ge.85.and.IPTCH.le.108) nzone = 4
          if(IPTCH.ge.109.and.IPTCH.le.126) nzone = 5
          if(IPTCH.ge.127.and.IPTCH.le.138) nzone = 6
          if(IPTCH.ge.139.and.IPTCH.le.144) nzone = 7
          if(IPTCH.eq.145) nzone = 8
          if(nzone.eq.8) then
            xp = 0.0
            yp = 0.0
            zp = 1.0
          elseif(nzone.eq.1) then
            aazim = pzazim(nzone)*(IPTCH - 1)
            xp = ecosd(aazim)*ecosd(pzalt(nzone))
            yp = esind(aazim)*ecosd(pzalt(nzone))
            zp = esind(pzalt(nzone))
          else
            aazim = pzazim(nzone)*((IPTCH - npz(nzone-1)) - 1)
            xp = ecosd(aazim)*ecosd(pzalt(nzone))
            yp = esind(aazim)*ecosd(pzalt(nzone))
            zp = esind(pzalt(nzone))
          endif

C Debug
C          write(6,*) 'IPTCH',' Xp',' Yp',' Zp',' azim',' alt'
C          write(6,*) IPTCH,' ',xp,' ',yp,' ',zp,' ',aazim,' ',pzalt   
C End Debug

          write(ITA3,'(a)') 'patch_light source patch'
          write(ITA3,'(a)') '0'
          write(ITA3,'(a)') '0'
          write(ITA3,'(a,4f10.6)') '4 ',xp,yp,zp,solid(nzone)
          call ERPFREE(ITA3,ISTAT)
          skydone=.true.

C Generate new octree.
          if (IBLND.eq.0) then
            rn=RIFNAME(ISCENE)
          else
            rn=LBSRIF(ISCENE)
          endif

C Recreate octree and get current file names.
          call touchrif(rn)
          write(outs,'(2a,i3)')' Daylight coefficient: ',
     &                         'Run oconv for patch ',IPTCH
          call edisp(iuout,outs)

C Check for output file only for first patch.
          if (IPTCH.eq.1) then

C Create temporary file (format: .PID.cmd)
            call esppid(ipid)
            write(outs,'(a,i7,a)') runpath(1:lnrp),ipid,'.dcf'
            call st2file(outs,LTMPFA)
            XST=.FALSE.
            INQUIRE (FILE=LTMPFA(1:lnblnk(LTMPFA)),EXIST=XST)
            if(XST)then
              call FPOPEN(ITA2,ISTAT,1,0,LTMPFA)
              call EFDELET(ITA2,ISTAT)
            endif
            call FPOPEN(ITA2,ISTAT,1,2,LTMPFA)
            write(ITA2,'(a)')'# Sensor illuminance for daylight coefs.'
            write(ITA2,'(a)')'# Temporary data file.'
            call ERPFREE(ITA2,ISTAT)
          endif

C Run rtrace.
         write(outs,98)' Daylight coefficient: ',
     &                      'Run rtrace for patch ',IPTCH
 98      format(2a,i3)

          write(doitl,'(4a,1x,9a)') 'cd ',runpath(1:lnrp),
     &      '; rtrace -ov -I -h @',
     &      optnfil(1:lnblnk(optnfil)),octfil(1:lnblnk(octfil)),
     &      ' < ',LDFGRID(ISCENE)(1:lnblnk(LDFGRID(ISCENE))),
     &      ' | rcalc -e ',QT,
     &      '$1=(0.265*$1+0.670*$2+0.065*$3)/(1000000*2*PI/145.)',
     &                               QT,' >>',LTMPFA(1:lnblnk(LTMPFA))
          call runit(doitl,'-')

C Display progress...
          if (IPTCH.eq.35) then
            call edisp(IUOUT,'Calculation 25% complete.')
          elseif (IPTCH.eq.70) then
            call edisp(IUOUT,'Calculation 50% complete.')
          elseif (IPTCH.eq.105) then
            call edisp(IUOUT,'Calculation 75% complete.')
          endif
 123    continue

C Read in daylight coefficients and save to cgc file.
        ISET=IBLND+1
        call RDCFTMP(LTMPFA,ISET)

C Remove temporary files.
        XST=.FALSE.
        INQUIRE (FILE=LTMPFA(1:lnblnk(LTMPFA)),EXIST=XST)
        if(XST)then
          call FPOPEN(ITA2,ISTAT,1,0,LTMPFA)
          call EFDELET(ITA2,ISTAT)
        endif
         
        call edisp(IUOUT,'Daylight coefficient set complete')

C Do other blind states.
        if (NBSRIF(ISCENE).gt.0) then
          IBLND=IBLND+1
          if (IBLND.le.NBSRIF(ISCENE)) then
            call edisp(IUOUT,'Calculating next blind state.')
            goto 1234
          endif
        endif
      endif

      return
      end


C ********************** settime **********************
C settime - user choice of standard times for sky generation

      SUBROUTINE settime(IRM,IRD,XRT)
#include "building.h"
#include "e2r_common.h"

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='settime'  ! set for subroutine

C Ask winter am/pm spring am/pm summer am/pm
      helptopic='standard_times_of_day'
      call gethelptext(helpinsub,helptopic,nbhelp)
      ino=0
      idno=1
      call MENUATOL('Select day & time for scene.',
     &    'Select one from list:',
     &    'a winter morning','b winter noon','c winter afternoon',
     &    'd spring morning','e spring noon','f spring afternoon',
     &    'g summer morning','h summer noon','i summer afternoon',' ',
     &    ' ',' ',ino,idno,nbhelp)
      IWDT=INO
      if(IWDT.eq.1)then
        irdoy=15
        rtime=10.0
      elseif(IWDT.eq.2)then
        irdoy=15
        rtime=12.0
      elseif(IWDT.eq.3)then
        irdoy=15
        rtime=15.0
      elseif(IWDT.eq.4)then
        irdoy=74
        rtime=9.5
      elseif(IWDT.eq.5)then
        irdoy=74
        rtime=12.0
      elseif(IWDT.eq.6)then
        irdoy=74
        rtime=15.5
      elseif(IWDT.eq.7)then
        irdoy=160
        rtime=9.0
      elseif(IWDT.eq.8)then
        irdoy=160
        rtime=12.0
      elseif(IWDT.eq.9)then
        irdoy=160
        rtime=16.0
      endif
      CALL EDAYR(irdoy,IRD,IRM)
      XRT=rtime

      return
      end

C ********************** touchrif **********************
C touchrif generates an options file based on information 
C generated by rad -t after removing current octree.

      SUBROUTINE touchrif(RIFFILE)
#include "building.h"
#include "e2r_common.h"
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      COMMON/FILEP/IFIL

      character doit*124,RIFFILE*72

C Read current rif file.
      ITA2=IFIL+7
      ITA3=IFIL+10
      call RRIF(ITA2,ITA3,RIFFILE,'s',IERR)
      
C Remove octree to force rebuild as radiance sometimes gets this wrong.
      write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &                   '; rm -f ',octfil(1:lnblnk(octfil))
      call runit(doit,'-')

C Run rad in 'touch up' mode.
      write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &                   '; rad -t ',RIFFILE(1:lnblnk(RIFFILE))
      call edisp(iuout,'Radiance feedback is displayed in xterm.')
      call runit(doit,'-')
      
      return
      end

C ********************** defview **********************
C defview generates a new default view.

      SUBROUTINE defview
#include "building.h"
#include "prj3dv.h"
#include "e2r_common.h"

      COMMON/FILEP/IFIL

      COMMON/RAY5/ZCOG(MCOM,3),XMN,YMN,ZMN,XMX,YMX,ZMX
      COMMON/RAY5OB/OXMN,OYMN,OZMN,OXMX,OYMX,OZMX

      common/initv/initvt,EYEMI(3),VIEWMI(3),ANGI

      real dvazim  ! default calculated viewing angle azimuth
      real dvelev  ! default calculated viewing angle elevation
      real dvangv,dvangh ! vertical and horizontal default viewing angles
      integer ier  ! for use with call to mkrif
      integer ita2 ! file unit for use with mkrif

      ITA2=IFIL+7

C External view point.
      if (SCENEPURP(ISCENE)(1:8).eq.'External') then

C Create a default view, set file name, set bounds for slightly
C smaller than the ground disk. Save off zone bounds before
C adding in the ground disk.
        OXMN=XMN
        OYMN=YMN
        OZMN=ZMN
        OXMX=XMX
        OYMX=YMX
        OZMX=ZMX
        XD=(XMX-XMN)**2 + (YMX-YMN)**2
        DD=SQRT(XD)*1.5
        cx=XMN+((XMX-XMN)/2.)
        cy=YMN+((YMX-YMN)/2.)
        XMN=cx-DD
        XMX=cx+DD
        YMN=cy-DD
        YMX=cy+DD
        ZMN=ZMN
        ZMX=DD
        rvpx=-100.
        rvpy=-100.
        rvpz=100.
        if(initvt.eq.1)then
          rvpx=EYEMI(1)
          rvpy=EYEMI(2)
          rvpz=EYEMI(3)
        endif

C Given the eye point and the view point return azimuth & elevation
C and set the default viewing angles to 1.2 factor.
        call ln2az(rvpx,rvpy,rvpz,VIEWM(1),VIEWM(2),VIEWM(3),
     &    dvazim,dvelev)
        call ang3vtx(OXMN,OYMN,OZMN,EYEM(1),EYEM(2),EYEM(3),OXMX,
     &    OYMX,OZMX,eang)
        dvangv=eang*1.2
        dvangh=eang*1.2

        call AZ2UV(dvazim,dvelev,vdx,vdy,vdz)
        write(vewcmds(1),'(a,3F9.3,a,3F8.4,a,F6.1,a,F6.1,a)') 
     &       '-vtv -vp ',rvpx,rvpy,rvpz,' -vd ',vdx,vdy,vdz,
     &       ' -vu 0 0 1 -vh ',dvangh,' -vv ',dvangv,' -vs 0 -vl 0 '
        rvewsh(1) = 'def'
        indxvew=1
        ipckvew=1

      elseif (SCENEPURP(ISCENE)(1:8).eq.'Internal') then

C Default internal view at max X average Y and Z, looking in -x dir.
        indxvew=0
        ipckvew=-1
      else
        indxvew=0
        ipckvew=-1
      endif

C Update rif file. No use yet made of ier.
      IFC=3
      IER=0
      call MKRIF(ITA2,RIFNAME(ISCENE),IFC,0,IER)
      if (NBSRIF(ISCENE).eq.1) then
        call mkrif(ita2,LBSRIF(ISCENE),IFC,1,ier)
      endif

      return
      end


C ********************** genimage **********************
C genimage generates an image to screen or file.
C ITP =1 - image only; =2 - glare info to display on image.
      SUBROUTINE genimage(ITP)
#include "building.h"
#include "site.h"
#include "e2r_common.h"
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      COMMON/FILEP/IFIL

      character tpic*72,tpicd*72,tgif*72,tgifd*72
      character pf*72,outs*124,ltmp*72
      character doit*256
      integer IWT,IWP   ! for radio buttons

      logical XST,anim,unixok
      CHARACTER*3 NMTHNM(12)

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      DATA NMTHNM/'Jan','Feb','Mar','Apr','May','Jun','Jul',
     &'Aug','Sep','Oct','Nov','Dec'/

      helpinsub='genimage'  ! set for subroutine
      ITA2=IFIL+7
      anim=.false.

      if (ITP.eq.1) then

C Ask if an animation required.
        helptopic='single_time_or_sequence'
        call gethelptext(helpinsub,helptopic,nbhelp)
        CALL EASKAB(' ',' Image(s):','single time instance',
     &    'sequence',IWDA,nbhelp)
        if(iwda.eq.2)then
          anim = .true.
          IWDQ=2
        else
          if(mono.gt.0)then
            helptopic='render_to_screen_or_file'
            call gethelptext(helpinsub,helptopic,nbhelp)
            CALL EASKAB(' ','Image rendering to:','screen','file',
     &        IWDQ,nbhelp)
          else
            IWDQ=2
          endif
        endif
      else

C If glare put it to file.
        IWDQ=2
      endif
      if(IWDQ.eq.1)then
      
C If in unix then use interactive rendering. If Native Windows do
C not try and display.
        call isunix(unixok)
        if (ipckvew.eq.-1) then 
          if(unixok)then
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &               '; rad -e -o x11 ',
     &               RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE))),' &'
          else
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &               '; rad -e ',
     &               RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE))),' &'
          endif
        elseif (ipckvew.eq.0) then 
          if(unixok)then
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &               '; rad -e -o x11 ',
     &               RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE))),' &'
          else
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &               '; rad -e ',
     &               RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE))),' &'
          endif
        else
          if(unixok)then
            write(doit,'(7a)') 'cd ',runpath(1:lnrp),
     &               '; rad -e -o x11 -v ',
     &               rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),' ',
     &               RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE))),' &'
          else
            write(doit,'(7a)') 'cd ',runpath(1:lnrp),
     &               '; rad -e -v ',
     &               rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),' ',
     &               RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE))),' &'
          endif
        endif

C Debug.
C        write(6,*) doit

        call runit(doit,'-')

C Display helpful messages while the image is rendering.
        call edisp(iuout,'Helpful rview commands:  ')
        call edisp(iuout,' All commands can be shortened, to use ')
        call edisp(iuout,' just type in the `rview` window.')
        call edisp(iuout,'  ')
        call edisp(iuout,' aim      - adjust the view direction.')
        call edisp(iuout,' exposure - adjust exposure:')
        call edisp(iuout,'           if `e +1` then increase 1 f stop.')
        call edisp(iuout,'           if `e 1` then exposure averaged.')
        call edisp(iuout,' last     - restore last view.  ')
        call edisp(iuout,' last [file] - restore view from file.')
        call edisp(iuout,' view     - save current view info > file.')
        call edisp(iuout,' write    - save current image to file.')
        call edisp(iuout,' quit     - give up preview. ')
        call edisp(iuout,'  ')
        call edisp(iuout,'For more info see the radiance manual. ')
      else
        if(anim)then

C Confirm end time and increment. ATIMST is the start time (real) and
C ITST is the start time (int).
          call edisp(iuout,' ')
          call edisp(iuout,' Date & time at start of animation...')
          iardoy=irdoy
          CALL EDAYR(iardoy,IADO,IAMO)
          ATIMEST=4.0
          CALL ASKTIM(2,1,IAMO,IADO,iardoy,ATIMEST,ITST,IER)

C Ask for end time of the animation.
          helptopic='end_time_of_animation'
          call gethelptext(helpinsub,helptopic,nbhelp)
          ATIMEFN = ATIMEST + 1.0
          CALL EASKR(ATIMEFN,' ',' End time of the animation? ',
     &      ATIMEST,'W',24.0,'W',0.2,'end time of anim',IER,nbhelp)

C Figure out the increment.
          IWT=1
          CALL EASKATOG('Interval between views:',' ','one min',
     &      'five min','ten min','15 min','20 min','30 min','cancel',
     &      IWT,nbhelp)
          if(IWT.EQ.1)then
            DT=0.016666
          elseif(IWT.EQ.2)then
            DT=0.083333
          elseif(IWT.EQ.3)then
            DT=0.166666
          elseif(IWT.EQ.4)then
            DT=0.25
          elseif(IWT.EQ.5)then
            DT=0.33333
          elseif(IWT.EQ.6)then
            DT=0.5
          elseif(IWT.EQ.7)then
            return
          endif

C Up the image quality if low.
          if(imgqua(1:3).eq.'Low')imgqua = 'Medium'

C Size of the images (set IFP to double so can filter).
          IWP=1
          CALL EASKATOG('Image frame size (pixels):',' ','240',
     &      '320','400','500','600','700','cancel',IWP,nbhelp)
          if(IWP.EQ.1)then
            ipicx=240
          elseif(IWP.EQ.2)then
            ipicx=320
          elseif(IWP.EQ.3)then
            ipicx=400
          elseif(IWP.EQ.4)then
            ipicx=500
          elseif(IWP.EQ.5)then
            ipicx=600
          elseif(IWP.EQ.6)then
            ipicx=700
          elseif(IWP.EQ.7)then
            return
          endif

C Loop from start and increment until at or past the finish time.
          idone=1
          CURT=ATIMEST
          do while (idone.ne.0)
            write(outs,'(a,2i3,f7.3,a,f5.2,2(a,f7.1),a)')'gensky',IAMO,
     &        IADO,CURT,' +s -g ',rgrfl,' -a ',sitelat,' -o ',
     &        -sitelongdif,' -m 0.0'
            CALL wrtsky(outs)

C We will need hdr & gif file for this time. Write out and then use
C sdelim with a N to remove spaces.
            write(tpic,'(a,2i3,f6.3,a)') runpath(1:lnrp),
     &        IAMO,IADO,CURT,'.hdr'
            call sdelim(tpic,tpicd,'N',IW)
            write(tgif,'(a,2i3,f6.3,a)') runpath(1:lnrp),
     &        IAMO,IADO,CURT,'.gif'
            call sdelim(tgif,tgifd,'N',IW)

C If animation use a standard name for hdr file (which is going to
C be converted into a timestamp named gif file. Any existing hdr
C file should be removed.
            if (ipckvew.gt.0) then
              write(pf,'(5a)') runpath(1:lnrp),
     &          picfil(1:lnblnk(picfil)),'_',
     &          rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.hdr'
            else
              write(pf,'(3a)') runpath(1:lnrp),
     &          picfil(1:lnblnk(picfil)),'_X.hdr'
            endif
            CALL ERPFREE(ITA2,ISTAT)
            INQUIRE (FILE=pf,EXIST=XST)
            if(XST)then
              call ERPFREE(ITA2,ISTAT)
              call FPOPEN(ITA2,ISTAT,1,1,pf)
              call EFDELET(ITA2,ISTAT)
            endif

C Save changes to RIF file
            IFC=3
            call MKRIF(ITA2,RIFNAME(ISCENE),IFC,0,IER)
            if (NBSRIF(ISCENE).eq.1) then
              call mkrif(ita2,LBSRIF(ISCENE),IFC,1,ier)
            endif

C call rad to create image(s) based on current setting of ipckvew.
            if (ipckvew.eq.-1) then 
              write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &          '; rad -e ',RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE)))
            elseif (ipckvew.eq.0) then 
              write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &          '; rad -e ',RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE)))
            else
              write(doit,'(6a)') 'cd ',runpath(1:lnrp),
     &        '; rad -e -v ',rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),
     &        ' ',RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE)))
            endif

C Debug.
            write(6,*) doit

            write(outs,'(2a,i3,F6.2)') 'Currently working on...',
     &        NMTHNM(IAMO),IADO,CURT
            call edisp(iuout,outs)
            call runit(doit,'-')

C Generate a label and put into tpic.
            write(doit,'(2a,i3,F6.2,4a)') 'psign -h 18 ',NMTHNM(IAMO),
     &        IADO,CURT,' | pcompos ',pf(1:lnblnk(pf)),' 0 0 - 2 2 > ',
     &        tpicd(1:lnblnk(tpicd))

C Debug.
            write(6,*) doit

            call runit(doit,'-')

C Generate command to convert to a gif.
            write(doit,'(4a)') 'ra_gif ',tpicd(1:lnblnk(tpicd)),' ',
     &        tgifd(1:lnblnk(tgifd))

C Debug.
            write(6,*) doit

            call runit(doit,'-')

C Increment the current time.
            CURT=CURT+DT
            if(CURT.gt.ATIMEFN)idone=0
          end do
        else

C See if there is an existing hdr file by this name.
          if (ipckvew.gt.0) then
            write(pf,'(5a)') runpath(1:lnrp),
     &        picfil(1:lnblnk(picfil)),'_',
     &        rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.hdr'
          else
            write(pf,'(3a)') runpath(1:lnrp),
     &        picfil(1:lnblnk(picfil)),'_X.hdr'
          endif
          CALL ERPFREE(ITA2,ISTAT)
          INQUIRE (FILE=pf,EXIST=XST)
          if(XST)then
            helptopic='overwrite_existing_pic'
            call gethelptext(helpinsub,helptopic,nbhelp)
            write(outs,'(a,a)') 'There is an existing picture file ',
     &        pf(1:lnblnk(pf))
            CALL EASKABC(outs,'Do you want to: ','overwrite',
     &        'choose another name','cancel',IWR,nbhelp)
            if(IWR.eq.3)then
              return
            elseif(IWR.eq.2)then
 1111         ltmp = picfil
              CALL EASKS(ltmp,
     &          ' Picture root name (modify slightly) ?',
     &          ' ',72,'xx','picture root file name',IER,nbhelp)
              if(ltmp(1:2).ne.'  ') then
                picfil = ltmp
              else
                goto 1111
              endif
              IFC=3
              call MKRIF(ITA2,RIFNAME(ISCENE),IFC,0,IER)
              if (NBSRIF(ISCENE).eq.1) then
                call mkrif(ita2,LBSRIF(ISCENE),IFC,1,ier)
              endif
            elseif(IWR.eq.1)then

C Set file name including path and open.
              call ERPFREE(ITA2,ISTAT)
              call FPOPEN(ITA2,ISTAT,1,1,pf)
              call EFDELET(ITA2,ISTAT)
            endif
          endif
        endif
        if (ipckvew.eq.-1) then 
          write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &          '; rad -e ',RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE)))
        elseif (ipckvew.eq.0) then 
          write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &          '; rad -e ',RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE)))
        else
          write(doit,'(6a)') 'cd ',runpath(1:lnrp),
     &       '; rad -e -v ',rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),
     &                 ' ',RIFNAME(ISCENE)(1:lnblnk(RIFNAME(ISCENE)))
        endif

C Debug.
        write(6,*) doit

        call edisp(iuout,'Look in the text window for progress.')
        call runit(doit,'-')
        if (ITP.eq.1)call dispimage(1)
      endif

      return
      end

C ********************** dispimage **********************
C dispimage displays an image file to screen.
C ITP =1 - image only; =2 - glare info to display on image.
C Assumes that the path to the image is given.

      SUBROUTINE dispimage(ITP)
#include "building.h"
#include "e2r_common.h"
      
      integer lnblnk  ! function definition

      COMMON/FILEP/IFIL
      COMMON/OUTIN/IUOUT,IUIN
      COMMON/SPAD/MMOD,LIMIT,LIMTTY
      integer menuchw,igl,igr,igt,igb,igw,igwh
      common/VIEWPX/menuchw,igl,igr,igt,igb,igw,igwh

      character doit*124,pf*72,gf*72,ugrf*72,ltmp*72
      character outs*124,outstr*124
      
      dimension UGRV(72),UGRANG(72)
#ifdef OSI
      integer igwid,igheight  ! for use with axiscale
      integer iix1,iiy1,iix2,iiy2
      integer iigl,iigr,iigt,iigb,iigw,iigwh
      integer iiw1,iiw2,iiw3,iiw4,iimenu
#else
      integer*8 igwid,igheight  ! for use with axiscale
      integer*8 iix1,iiy1,iix2,iiy2
      integer*8 iigl,iigr,iigt,iigb,iigw,iigwh
      integer*8 iiw1,iiw2,iiw3,iiw4,iimenu
#endif
      
      logical XST,unixok

C Generate picture and glare file names.
      if (ipckvew.gt.0) then
        write(pf,'(4a)') picfil(1:lnblnk(picfil)),'_',
     &                rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.hdr'
        write(gf,'(4a)') picfil(1:lnblnk(picfil)),'_',
     &                rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.glr'
      else
        write(pf,'(2a)') picfil(1:lnblnk(picfil)),'_X.hdr'
        write(gf,'(2a)') picfil(1:lnblnk(picfil)),'_X.glr'
      endif

      if (ITP.eq.1) then
        call isunix(unixok)
        if(unixok)then
          call edisp(iuout,' Starting ximage with the commands:')
          if(mono.eq.0)then
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &       '; ximage -m ',pf(1:lnblnk(pf)),' &'
          elseif(mono.eq.1)then
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &       '; ximage -b ',pf(1:lnblnk(pf)),' &'
          elseif(mono.eq.2)then
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &       '; ximage ',pf(1:lnblnk(pf)),' &'
          endif
          call runit(doit,'-')
        else
          call edisp(iuout,' ximage not available on Windows.')
        endif
      elseif (ITP.eq.2) then
      
C First display glare sources on image.
        write(doit,'(7a)') 'cd ',runpath(1:lnrp),
     &       '; xglaresrc ',pf(1:lnblnk(pf)),' ',gf(1:lnblnk(gf)),' &'
        call runit(doit,'-')

C Calculate UGR from glare file and display to screen.
        write (doit,'(7a)') 'cd ',runpath(1:lnrp),
     &      '; glarendx -t ugr -h ',gf(1:lnblnk(gf)),' > ',
     &      gf(1:lnblnk(gf)),'.ugr'
        call runit(doit,'-')
        
C Read file then display graph.
C Check for daylight factor results.
        write (ugrf,'(2a)') gf(1:lnblnk(gf)),'.ugr'
        write (ltmp,'(2a)') 
     &             runpath(1:lnrp),ugrf(1:lnblnk(ugrf))
        ITA1 = IFIL+6
        call ERPFREE(ITA1,ISTAT)
        call FINDFIL(ltmp,XST)
        if(XST)then
          call edisp (iuout,'Angle  UGR')
          XMIN=0.0
          XMAX=0.0
          YMIN=0.
          YMAX=1.0
          call FPOPEN(ITA1,ISTAT,1,1,ltmp)
          NUGR=0
          if(ISTAT.eq.0)then
  43        CALL STRIPC(ITA1,OUTSTR,0,ND,0,'UGR results',IFER)
            if (IFER.eq.0.and.NUGR.lt.72) then
              NUGR=NUGR+1
              K=0
              CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','angle',IER)
              UGRANG(NUGR)=-1.*XTMP
              CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','UGR value',IER)
              UGRV(NUGR)=XTMP
              xmin=amin1(xmin,UGRANG(NUGR))
              xmax=amax1(xmax,UGRANG(NUGR))
              ymin=amin1(ymin,UGRV(NUGR))
              ymax=amax1(ymax,UGRV(NUGR))
              write (outs,'(f6.1,f6.2)') UGRANG(NUGR),UGRV(NUGR)
              call edisp (iuout,outs)
              goto 43
            endif
          endif
          call ERPFREE(ITA1,ISTAT)
          call edisp (iuout,'Note: -ive angle to left of view center.')
          if (MMOD.eq.8) then
            CALL startbuffer()

C Setup and pass in parameters to win3d.
            iiw1=8; iiw2=8; iiw3=5; iiw4=3; iimenu=menuchw
            iigl=igl; iigr=igr; iigt=igt; iigb=igb; iigw=igw; iigwh=igwh
            CALL win3d(iimenu,iiw1,iiw2,iiw3,iiw4,
     &        iigl,iigr,iigt,iigb,iigw,iigwh)
            igl=int(iigl); igr=int(iigr); igt=int(iigt); igb=int(iigb)
            igw=int(iigw); igwh=int(iigwh)
            igwid=igw
            igheight=igwh
            call axiscale(igwid,igheight,XMIN,XMAX,YMIN,YMAX,xsc,ysc,
     &                  sca,Xadd,Yadd)

C Stuff into static variables for later access and draw axis.
            call linescale(iigl,Xadd,xsc,iigb,Yadd,ysc)
            call vrtaxis(YMIN,YMAX,iigl,iigb,iigt,Yadd,ysc,0,0,'UGR')
            call horaxis(XMIN,XMAX,iigl,iigr,iigb,Xadd,xsc,0,
     &        'Degrees from view center')

C Draw values as a circle.
            call u2pixel(UGRANG(1),UGRV(1),iix1,iiy1)
            CALL ecirc(iix1,iiy1,3,1)
            do 10 I=2,NUGR
              call u2pixel(UGRANG(I),UGRV(I),iix2,iiy2)
              call edwline(iix1,iiy1,iix2,iiy2)
              CALL ecirc(iix2,iiy2,3,1)
              iix1=iix2
              iiy1=iiy2
 10         continue
            call forceflush()
          endif
        endif
      else
        return
      endif

      return
      end

C ********************** getglr **********************
C getglr recovers view information and runs glare calculation.

      SUBROUTINE getglr
#include "building.h"
#include "e2r_common.h"
      
      integer lnblnk  ! function definition
      integer iCountWords

      COMMON/FILEP/IFIL

      character rendopt*200
      character word*12,doit*300,ltmp*200,gf*72,pf*72,glst*4

      ITA2 = IFIL+7
      ITA3 = IFIL+10

      IER=0
      call RRIF(ita2,ita3,RIFNAME(ISCENE),'s',IER)

C Check if view info is in a file or kept in the rif file and set 
C glare angle (set minimum angle to 90 degrees).
      glang=90.
      if (vewcmds(ipckvew)(1:3).eq.'-vf') then
        K=4
        CALL EGETW(vewcmds(ipckvew),K,ltmp,'-','view file',IFLAG) 
        call RRVEW(ITA2,ltmp,IER)
        if ((angh/2.).gt.glang) glang=angh/2.
        if ((angv/2.).gt.glang) glang=angv/2.
      else
        K=0
        ITMS = iCountWords(vewcmds(ipckvew))
        do 2112 IX=1,(ITMS-1)
          CALL EGETW(vewcmds(ipckvew),K,word,'-','view data',IFLAG)
          if (word(1:3).eq.'-vh'.or.word(1:3).eq.'-vv') then
            CALL EGETWR(vewcmds(ipckvew),K,ang,0.0,360.0,'W',
     &                                          'view angle',IFLAG)
            if ((ang/2.).gt.glang) glang=ang/2.
          endif
 2112   continue
      endif

C Round glang up to next multiple of ten degrees.
      test=(glang/10.0)-float(INT(glang/10.0))
      if (abs(test).ge.0.001) then
        glang=float(INT(glang/10.)+1)*10.
      endif

C Create strings of maximum angle and glare file name (based on pic name).
      write (word,'(i4)') INT(glang)
      K=0
      CALL EGETW(word,K,glst,'-','max glr angle',IFLAG)
      
C Read opt file so as rendering parameters can be set for rtrace.
      ltmp=' '
      rendopt=' '
      xval=-1.
      call RADPAR('dp',xval)
      write (ltmp,'(a,i4)') '-dp ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('ds',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -ds ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('dj',xval)
      if (xval.gt.0.) then

C Debug.
C        write(6,*) ' -dj',xval

        write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -dj ',xval
        write (rendopt,'(a)') ltmp
      endif
      xval=-1.
      call RADPAR('dt',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -dt ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('dc',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -dc ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('dr',xval)
      write (ltmp,'(2a,i2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -dr ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('sj',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -sj ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('st',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -st ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('ab',xval)
      write (ltmp,'(2a,i2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -ab ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('aa',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -aa ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('ad',xval)
      write (ltmp,'(2a,i4,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -ad ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('as',xval)
      write (ltmp,'(2a,i4,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -as ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('ar',xval)
      write (ltmp,'(2a,i4,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -ar ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('av',xval)
      write (ltmp,'(2a,3(1x,f4.1),1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -av',xval,xval,xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('lr',xval)
      write (ltmp,'(2a,i2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -lr ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('lw',xval)
      write (ltmp,'(2a,f5.3,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -lw ',xval
      write (rendopt,'(a)') ltmp

C Run findglare to identify glare sources.
      if (ipckvew.gt.0) then
        write(pf,'(a,a,a,a)') picfil(1:lnblnk(picfil)),'_',
     &                rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.hdr'
        write(gf,'(a,a,a,a)') picfil(1:lnblnk(picfil)),'_',
     &                rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.glr'
      else
        write(pf,'(a,a)') picfil(1:lnblnk(picfil)),'_X.hdr'
        write(gf,'(a,a)') picfil(1:lnblnk(picfil)),'_X.glr'
      endif
      write(doit,'(12a)') 'cd ',runpath(1:lnblnk(runpath)),
     &  '; findglare -ga 5-',glst(1:lnblnk(glst)),':5 -p ',
     &   pf(1:lnblnk(pf)),' ',rendopt(1:lnblnk(rendopt)),' ',
     &   octfil(1:lnblnk(octfil)),' > ',gf(1:lnblnk(gf))

C Debug.
      write(6,*) doit

      call runit(doit,'-')

      return
      end

C ********************** getdf **********************
C getdf runs daylight factor calculation and then displays them.

      SUBROUTINE getdf
#include "building.h"
#include "e2r_common.h"
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      COMMON/FILEP/IFIL

      CHARACTER df*72,outs*124,ltmp*72,doit*256
      character QT*1,OUTSTR*124
      character tfile*72,outsl*160

      logical XST,RECALC

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='getdf'  ! set for subroutine

      ITA1 = IFIL+6
      ITA2 = IFIL+7
      QT=CHAR(39)

C Check for daylight factor points - if none then try and read grid file.
      if (NDFP.eq.0) then
        call ERPFREE(ITA1,ISTAT)
        write(tfile,'(a,a)')runpath(1:lnrp),
     &    LDFGRID(ISCENE)(1:lnblnk(LDFGRID(ISCENE)))
        call FPOPEN(ITA1,ISTAT,1,1,tfile)
        if(ISTAT.eq.0)then
  42      CALL STRIPC(ITA1,OUTSTR,0,ND,0,'grid points',IFER)
          if (IFER.eq.0) then
            NDFP=NDFP+1
            K=0
            CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','grid x',IER)
            DFPTS(NDFP,1)=XTMP
            CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','grid y',IER)
            DFPTS(NDFP,2)=XTMP
            CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','grid z',IER)
            DFPTS(NDFP,3)=XTMP
            CALL EGETWR(OUTSTR,K,DFDIR(1),0.,0.,'-','vec x',IER)
            CALL EGETWR(OUTSTR,K,DFDIR(2),0.,0.,'-','vec y',IER)
            CALL EGETWR(OUTSTR,K,DFDIR(3),0.,0.,'-','vec z',IER)
            goto 42
          endif
          CALL DFGRIDLBL('g')
        endif
        call ERPFREE(ITA1,ISTAT)
      endif
      if (NDFP.eq.0) then
        CALL USRMSG('Could not read grid points file.',
     &     'Cannot simulate without this information.  Returning.','W')
        return
      endif

C Ask for convergence limit.
      CONV=0.25
      helptopic='e2r_df_convergence'
      call gethelptext(helpinsub,helptopic,nbhelp)
      CALL EASKR(CONV,'Daylight factor convergence criteria',
     &  'Max total diff between iterations) ',0.00,
     &  'F',5.0,'W',0.25,'df convergence criteria',IER,nbhelp)

C Reset DFVALS to 0.0
      do 5 I=1,500
        DFVALS(I)=0.0
 5    continue
      ICONV=0

C Check octree up to date.
      call touchrif(RIFNAME(ISCENE))
      
C Check rendering parameters.  If the number of ambient bounces is 
C greater than 1 then the simulation has probably been run before. 
C Ask if the parameters should be reset.
      XAB=-1.
      call RADPAR('ab',XAB)
      if (XAB.gt.1.5) then
        helptopic='e2r_df_confusion'
        call gethelptext(helpinsub,helptopic,nbhelp)
        CALL EASKAB('The rendering parameters would appear to be set',
     &    'from a previous simulation.  Do you want to: ','use them',
     &    'start from beginning (recommended)',IWR,nbhelp)
        if (IWR.eq.2) then
          write (outsl,'(2a)') crenrp(1:lnblnk(crenrp)),
     &                         ' -ab 1 -ad 1024 -as 512 -av 0 0 0'
          write (crenrp,'(a)') outsl
          IFC=3
          call MKRIF(ITA2,RIFNAME(ISCENE),IFC,0,IER)
          call touchrif(RIFNAME(ISCENE))
        endif
      endif

C Daylight factors output file.
      write (df,'(2a)') SCENERT(ISCENE)(1:lnblnk(SCENERT(ISCENE))),'.df'
      call ERPFREE(ITA1,ISTAT)
 1111 write (ltmp,'(2a)') runpath(1:lnrp),df(1:lnblnk(df))
      call FINDFIL(ltmp,XST)
      helptopic='e2r_df_file_overwrite'
      call gethelptext(helpinsub,helptopic,nbhelp)
      if(XST)then
        write(outs,'(2a)')'There is an existing file ',df(1:lnblnk(df))
        CALL EASKAB(outs,'Do you want to: ','overwrite',
     &                            'choose another name',IWR,0)
        if (IWR.eq.2) then
          ltmp = df
 1221     CALL EASKS(ltmp,
     &      'Daylight factors results file name (modify slightly) ?',
     &      ' ',72,'xx.df','df resfile name',IER,nbhelp)
          if(ltmp.ne.'  '.and.ltmp.ne.df) then
            df = ltmp
          else
            goto 1221
          endif
          goto 1111
        else
          write(ltmp,'(2a)')runpath(1:lnrp),df(1:lnblnk(df))
          call FPOPEN(ITA1,ISTAT,1,1,ltmp)
          CALL EFDELET(ITA1,ISTAT)
        endif
      endif

C Open sky file and read ground ambient level.
      call RRSKY(ITA1,ga,IER)

C Call rtrace and calculate daylight factors. This is the point where
C the logic jumps back to if additional resolution is required.
 99   write(doit,'(4a,1x,6a,f5.2,4a)') 'cd ',runpath(1:lnrp),
     &  '; rtrace -opv -I -h @',optnfil(1:lnblnk(optnfil)),
     &  octfil(1:lnblnk(octfil)),
     &  ' < ',LDFGRID(ISCENE)(1:lnblnk(LDFGRID(ISCENE))),
     &  ' | rcalc -e ',QT,
     &  '$1=$1;$2=$2;$3=$3;$4=((0.265*$4+0.670*$5+0.065*$6)*100)/(PI*',
     &  ga,')',QT,' > ',df(1:lnblnk(df))
      call runit(doit,'-')

C Now need to read in daylight factors and store in memory.
      DFmaxdiff=0.
      write (ltmp,'(2a)') runpath(1:lnrp),df(1:lnblnk(df))
      call FPOPEN(ITA1,ISTAT,1,1,ltmp)
      do 10 I=1,NDFP
        call STRIPC(ITA1,OUTSTR,4,ND,0,'DF results',IER)
        K=0
        call EGETWR(OUTSTR,K,X,0.0,0.0,'-','X coord',IER)
        call EGETWR(OUTSTR,K,Y,0.0,0.0,'-','Y coord',IER)
        call EGETWR(OUTSTR,K,Z,0.0,0.0,'-','Z coord',IER)
        call EGETWR(OUTSTR,K,DFval,0.0,100.0,'W','DF',IER)
        do 20 J=1,NDFP
          if (abs(DFPTS(J,1)-X).lt.0.001) then
            if (abs(DFPTS(J,2)-Y).lt.0.001) then
              if (abs(DFPTS(J,3)-Z).lt.0.001) then

C Found the DF for the current sensor.
                if (abs(DFVALS(J)-DFval).gt.DFmaxdiff) then
                  DFmaxdiff=abs(DFVALS(J)-DFval)
                endif
                DFVALS(J)=DFval
              endif
            endif
          endif
 20     continue
 10   continue

C Debug.
C      write(6,*) DFmaxdiff

C Display current results and ambient rendering parameters.
      call DFGRIDLBL('d')
      XAB=-1.
      XAD=-1.
      XAS=-1.
      call RADPAR('ab',XAB)
      call RADPAR('ad',XAD)
      call RADPAR('as',XAS)
      write (outs,'(a,i2,2(a,i4))') 'Ambient parameter settings: -ab ',
     &              nint(XAB),' -ad ',nint(XAD),' -as ',nint(XAS)
      call edisp(iuout,outs)

C Check for convergance.
      RECALC=.false.

C Check value of ad.
      if (ICONV.eq.0) then
        YAD=-1.0
        call RADPAR('ad',YAD)
        if (DFmaxdiff.gt.CONV) then

C Increase value and recalculate.
          if (YAD.lt.4000.0) then
            YAD=YAD*2.
            call RADPAR('ad',YAD)
            RECALC=.true.
          else
            DFmaxdiff=9999.9
            ICONV=1
          endif
        else

C Decrease value (last change had no effect) and increase as.
          if (YAD.gt.1025.0) then
            YAD=YAD/2.
            call RADPAR('ad',YAD)
            DFmaxdiff=9999.9
            ICONV=1
          endif
        endif
      endif

C Check value of as.
      if (ICONV.eq.1) then
        YAS=-1.0
        call RADPAR('as',YAS)
        if (DFmaxdiff.gt.CONV) then

C Increase value and recalculate.
          if (YAS.lt.((YAD/2.0)-1.0)) then
            YAS=YAS*2.
            call RADPAR('as',YAS)
            RECALC=.true.
          else
            DFmaxdiff=9999.9
            ICONV=2
          endif
        else

C Decrease value (last change had no effect) and increase ab.
          if (YAS.gt.513.0) then
            YAS=YAS/2.
            call RADPAR('as',YAS)
            DFmaxdiff=9999.9
            ICONV=2
          endif
        endif
      endif

C Check value of ab.
      if (ICONV.eq.2) then
        YAB=-1.0
        call RADPAR('ab',YAB)
        if (DFmaxdiff.gt.CONV) then

C Increase value and recalculate.
          if (YAB.lt.5.0) then
            YAB=YAB+1.0
            call RADPAR('ab',YAB)
            RECALC=.true.
          else
            DFmaxdiff=9999.9
            ICONV=3
          endif
        else

C Decrease value (last change had no effect) and increase ??.
          if (YAB.gt.2.0) then
            YAB=YAB-1.0
            call RADPAR('ab',YAB)
            DFmaxdiff=9999.9
            ICONV=3
          endif
        endif
      endif

C Save RIF file and update options file.
      if (RECALC) then
        call edisp(iuout,'Recalculating with different resolution...')
        IFC=3
        call MKRIF(ITA2,RIFNAME(ISCENE),IFC,0,IER)
        call touchrif(RIFNAME(ISCENE))
        if (NBSRIF(ISCENE).eq.1) then
          call mkrif(ita2,LBSRIF(ISCENE),IFC,1,ier)
          call touchrif(LBSRIF(ISCENE))
        endif

C Move results file and recalculate DFs. Note this move creates
C a catch-22 for viewing the DF later on.
        call ERPFREE(ITA1,ISTAT)
        write(doit,'(7a)') 'cd ',runpath(1:lnrp),'; mv ',
     &        df(1:lnblnk(df)),' ',df(1:lnblnk(df)),'-'
        call runit(doit,'-')
        goto 99
      endif
      call ERPFREE(ITA1,ISTAT)

      return
      end


C ********************** getlux **********************
C getlux runs illuminance calculation and then displays them
C using logic similar to getdf.

      SUBROUTINE getlux
#include "building.h"
#include "e2r_common.h"
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      COMMON/FILEP/IFIL

      CHARACTER df*72,outs*124,ltmp*72,doit*256
      character QT*1,OUTSTR*124
      character tfile*72,outsl*160

      logical XST,RECALC

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='getlux'  ! set for subroutine

      ITA1 = IFIL+6
      ITA2 = IFIL+7
      QT=CHAR(39)

C Check for illuminance points - if none then try and read grid file.
      if (NDFP.eq.0) then
        call ERPFREE(ITA1,ISTAT)
        write(tfile,'(a,a)')runpath(1:lnrp),
     &    LDFGRID(ISCENE)(1:lnblnk(LDFGRID(ISCENE)))
        call FPOPEN(ITA1,ISTAT,1,1,tfile)
        if(ISTAT.eq.0)then
  42      CALL STRIPC(ITA1,OUTSTR,0,ND,0,'grid points',IFER)
          if (IFER.eq.0) then
            NDFP=NDFP+1
            K=0
            CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','grid x',IER)
            DFPTS(NDFP,1)=XTMP
            CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','grid y',IER)
            DFPTS(NDFP,2)=XTMP
            CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','grid z',IER)
            DFPTS(NDFP,3)=XTMP
            CALL EGETWR(OUTSTR,K,DFDIR(1),0.,0.,'-','vec x',IER)
            CALL EGETWR(OUTSTR,K,DFDIR(2),0.,0.,'-','vec y',IER)
            CALL EGETWR(OUTSTR,K,DFDIR(3),0.,0.,'-','vec z',IER)
            goto 42
          endif
          CALL DFGRIDLBL('g')
        endif
        call ERPFREE(ITA1,ISTAT)
      endif
      if (NDFP.eq.0) then
        CALL USRMSG('Could not read grid points file.',
     &     'Cannot simulate without this information.  Returning.','W')
        return
      endif

C Ask for convergence limit.
      CONV=0.25
      helptopic='e2r_lux_convergence'
      call gethelptext(helpinsub,helptopic,nbhelp)
      CALL EASKR(CONV,'illuminance convergence criteria',
     &  'Max total diff between iterations) ',1.00,
     &  'F',100.0,'W',10.0,'lux convergence criteria',IER,nbhelp)

C Reset DFVALS (holding lux values) to 0.0
      do 5 I=1,500
        DFVALS(I)=0.0
 5    continue
      ICONV=0

C Check octree up to date.
      call touchrif(RIFNAME(ISCENE))
      
C Check rendering parameters.  If the number of ambient bounces is 
C greater than 1 then the simulation has probably been run before. 
C Ask if the parameters should be reset.
      XAB=-1.
      call RADPAR('ab',XAB)
      if (XAB.gt.1.5) then
        helptopic='e2r_lux_confusion'
        call gethelptext(helpinsub,helptopic,nbhelp)
        CALL EASKAB('The rendering parameters would appear to be set',
     &    'from a previous simulation.  Do you want to: ','use them',
     &    'start from beginning (recommended)',IWR,nbhelp)
        if (IWR.eq.2) then
          write (outsl,'(2a)') crenrp(1:lnblnk(crenrp)),
     &                         ' -ab 1 -ad 1024 -as 512 -av 0 0 0'
          write (crenrp,'(a)') outsl
          IFC=3
          call MKRIF(ITA2,RIFNAME(ISCENE),IFC,0,IER)
          call touchrif(RIFNAME(ISCENE))
        endif
      endif

C Illuminance output file.
      write (df,'(2a)') SCENERT(ISCENE)(1:lnblnk(SCENERT(ISCENE))),
     &  '.lux'
      call ERPFREE(ITA1,ISTAT)
 1111 write (ltmp,'(2a)') runpath(1:lnrp),df(1:lnblnk(df))
      call FINDFIL(ltmp,XST)
      helptopic='e2r_lux_file_overwrite'
      call gethelptext(helpinsub,helptopic,nbhelp)
      if(XST)then
        write(outs,'(2a)')'There is an existing file ',df(1:lnblnk(df))
        CALL EASKAB(outs,'Do you want to: ','overwrite',
     &                   'choose another name',IWR,0)
        if (IWR.eq.2) then
          ltmp = df
 1221     CALL EASKS(ltmp,
     &      'Illuminance results file name (modify slightly) ?',
     &      ' ',72,'xx.lux','lux resfile name',IER,nbhelp)
          if(ltmp.ne.'  '.and.ltmp.ne.df) then
            df = ltmp
          else
            goto 1221
          endif
          goto 1111
        else
          write(ltmp,'(2a)')runpath(1:lnrp),df(1:lnblnk(df))
          call FPOPEN(ITA1,ISTAT,1,1,ltmp)
          CALL EFDELET(ITA1,ISTAT)
        endif
      endif

C Open sky file and read ground ambient level.
      call RRSKY(ITA1,ga,IER)

C Call rtrace and calculate illuminance. This is the point where
C the logic jumps back to if additional resolution is required.
 99   write(doit,'(4a,1x,9a)') 'cd ',runpath(1:lnrp),
     &  '; rtrace -opv -I -h @',optnfil(1:lnblnk(optnfil)),
     &  octfil(1:lnblnk(octfil)),
     &  ' < ',LDFGRID(ISCENE)(1:lnblnk(LDFGRID(ISCENE))),
     &  ' | rcalc -e ',QT,
     &  '$1=$1;$2=$2;$3=$3;$4=179*(0.265*$4+0.670*$5+0.065*$6)',
     &  QT,' > ',df(1:lnblnk(df))
      call runit(doit,'-')

C Now need to read in lux and store in memory.
      DFmaxdiff=0.
      write (ltmp,'(2a)') runpath(1:lnrp),df(1:lnblnk(df))
      call FPOPEN(ITA1,ISTAT,1,1,ltmp)
      do 10 I=1,NDFP
        call STRIPC(ITA1,OUTSTR,4,ND,0,'lux results',IER)
        K=0
        call EGETWR(OUTSTR,K,X,0.0,0.0,'-','X coord',IER)
        call EGETWR(OUTSTR,K,Y,0.0,0.0,'-','Y coord',IER)
        call EGETWR(OUTSTR,K,Z,0.0,0.0,'-','Z coord',IER)
        call EGETWR(OUTSTR,K,DFval,0.0,20000.0,'W','lux',IER)
        do 20 J=1,NDFP
          if (abs(DFPTS(J,1)-X).lt.0.001) then
            if (abs(DFPTS(J,2)-Y).lt.0.001) then
              if (abs(DFPTS(J,3)-Z).lt.0.001) then

C Found the DF for the current sensor.
                if (abs(DFVALS(J)-DFval).gt.DFmaxdiff) then
                  DFmaxdiff=abs(DFVALS(J)-DFval)
                endif
                DFVALS(J)=DFval
              endif
            endif
          endif
 20     continue
 10   continue

C Debug.
C      write(6,*) DFmaxdiff

C Display current results and ambient rendering parameters.
      call DFGRIDLBL('l')
      XAB=-1.
      XAD=-1.
      XAS=-1.
      call RADPAR('ab',XAB)
      call RADPAR('ad',XAD)
      call RADPAR('as',XAS)
      write (outs,'(a,i2,2(a,i4))') 'Ambient parameter settings: -ab ',
     &              nint(XAB),' -ad ',nint(XAD),' -as ',nint(XAS)
      call edisp(iuout,outs)

C Check for convergance.
      RECALC=.false.

C Check value of ad.
      if (ICONV.eq.0) then
        YAD=-1.0
        call RADPAR('ad',YAD)
        if (DFmaxdiff.gt.CONV) then

C Increase value and recalculate.
          if (YAD.lt.4000.0) then
            YAD=YAD*2.
            call RADPAR('ad',YAD)
            RECALC=.true.
          else
            DFmaxdiff=9999.9
            ICONV=1
          endif
        else

C Decrease value (last change had no effect) and increase as.
          if (YAD.gt.1025.0) then
            YAD=YAD/2.
            call RADPAR('ad',YAD)
            DFmaxdiff=9999.9
            ICONV=1
          endif
        endif
      endif

C Check value of as.
      if (ICONV.eq.1) then
        YAS=-1.0
        call RADPAR('as',YAS)
        if (DFmaxdiff.gt.CONV) then

C Increase value and recalculate.
          if (YAS.lt.((YAD/2.0)-1.0)) then
            YAS=YAS*2.
            call RADPAR('as',YAS)
            RECALC=.true.
          else
            DFmaxdiff=9999.9
            ICONV=2
          endif
        else

C Decrease value (last change had no effect) and increase ab.
          if (YAS.gt.513.0) then
            YAS=YAS/2.
            call RADPAR('as',YAS)
            DFmaxdiff=9999.9
            ICONV=2
          endif
        endif
      endif

C Check value of ab.
      if (ICONV.eq.2) then
        YAB=-1.0
        call RADPAR('ab',YAB)
        if (DFmaxdiff.gt.CONV) then

C Increase value and recalculate.
          if (YAB.lt.5.0) then
            YAB=YAB+1.0
            call RADPAR('ab',YAB)
            RECALC=.true.
          else
            DFmaxdiff=9999.9
            ICONV=3
          endif
        else

C Decrease value (last change had no effect) and increase ??.
          if (YAB.gt.2.0) then
            YAB=YAB-1.0
            call RADPAR('ab',YAB)
            DFmaxdiff=9999.9
            ICONV=3
          endif
        endif
      endif

C Save RIF file and update options file.
      if (RECALC) then
        call edisp(iuout,'Recalculating with different resolution...')
        IFC=3
        call MKRIF(ITA2,RIFNAME(ISCENE),IFC,0,IER)
        call touchrif(RIFNAME(ISCENE))
        if (NBSRIF(ISCENE).eq.1) then
          call mkrif(ita2,LBSRIF(ISCENE),IFC,1,ier)
          call touchrif(LBSRIF(ISCENE))
        endif

C Move results file and recalculate lux. Note this move creates
C a catch-22 for viewing the lux later on.
        call ERPFREE(ITA1,ISTAT)
        write(doit,'(7a)') 'cd ',runpath(1:lnrp),'; mv ',
     &        df(1:lnblnk(df)),' ',df(1:lnblnk(df)),'-'
        call runit(doit,'-')
        goto 99
      endif
      call ERPFREE(ITA1,ISTAT)

      return
      end

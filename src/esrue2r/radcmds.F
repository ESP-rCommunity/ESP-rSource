C This file is part of the ESP-r system.
C Copyright Energy Systems Research Unit, University of
C Strathclyde, Glasgow Scotland, 2001.

C ESP-r is free software.  You can redistribute it and/or
C modify it under the terms of the GNU General Public
C License as published by the Free Software Foundation 
C (version 2 orlater).

C ESP-r is distributed in the hope that it will be useful
C but WITHOUT ANY WARRANTY; without even the implied
C warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
C PURPOSE. See the GNU General Public License for more
C details.

C You should have received a copy of the GNU General Public
C License along with ESP-r. If not, write to the Free
C Software Foundation, Inc., 59 Temple Place, Suite 330,
C Boston, MA 02111-1307 USA.

C This file contains routines which execute Radiance commands.
C  autorad   - executes the Radiance commands for a particular command 
C              line act
C  simscene  - simulates daylight coefficients and coupling (called from bps)
C  settime   - user choice of standard times for sky generation
C  touchrif  - generates an options file based on information 
C              generated by rad -t after removing current octree.
C  defview   - generates a new default view.
C  genimage  - generates image(s) to screen or file.
C  dispimage - displays an image file to screen.
C  getglr    - recovers view information and runs glare calculation.
C  getdf     - runs daylight factor calculation.

C Useful block of code:
C          if(pathtype(1:9).eq.'radinhome')then
C          elseif(pathtype(1:8).eq.'radincfg')then
C          elseif(pathtype(1:8).eq.'radinrad')then
C          endif

C ********************** autorad **********************
C autorad options:
C  'Create' - depending on scene purpose create Radiance model
C  else simulate the scene by calling simscene

      SUBROUTINE autorad
#include "building.h"
      
      integer lnblnk  ! function definition

      COMMON/FILEP/IFIL
      common/pophelp/h(60)
      common/expath/runpath,pathtype

      COMMON/C4/XLAT,XLON

      common/sky1/rgrfl,isky,irdoy,rtime,iryear
      common/rad1/rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      common/raddn/skydone,outdone,indone,misdone,vewdone,glzdone
      common/raddata/SCENE(MCOM+1),RIFNAME(MCOM+1),SCENERT(MCOM+1),
     &               RIFDESC(MCOM+1),RIFPURP(MCOM+1)
      common/raddata2/NSCENE,ISCENEFOC
      common/raddata3/NBSRIF(MCOM+1),LBSRIF(MCOM+1)
      common/cmddata/zone,aim,act

      character*72 rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      character SCENE*28,RIFNAME*72,SCENERT*28,RIFDESC*72,RIFPURP*12
      character zone*16,aim*12,act*72,LBSRIF*72
      character outs*124,runpath*72,pathtype*24,tfile*72,h*72

      logical skydone,outdone,indone,misdone,vewdone,glzdone
      LOGICAL fict,XST,OK,DOK

      ITA2=IFIL+7
      ITA3=IFIL+10

C Create a default scene based on current information - ask 
C for additional info if necessary.
      if (act(1:6).ne.'Create') then
        call simscene

C Quit.
        call tstamp('>','Finish automatic visual analysis')
        CALL EPAGEND
        STOP
      endif


C For each scene purpose generate typical sky file.
C Process daylight coefficients seperately as sky file is artificial.
      if (RIFPURP(ISCENEFOC)(1:8).eq.'Day_coef') then

C Search for existing 'sky' file. (If found delete)
        write(tfile,'(2a)')runpath(1:lnblnk(runpath)),
     &                     rskyfil(1:lnblnk(rskyfil))
        INQUIRE (FILE=tfile,EXIST=XST)
        if(XST)then
          call FPOPEN(ITA3,ISTAT,1,0,tfile)
          call EFDELET(ITA3,ISTAT)
        endif
        call FPOPEN(ITA3,ISTAT,1,2,tfile)
        write(ITA3,'(a)') '# sky patch: 0'
        write(ITA3,'(a)') '  '
        write(ITA3,'(a)') 'void  light  patch_light'
        write(ITA3,'(a)') '0 '
        write(ITA3,'(a)') '0 '
        write(ITA3,'(a)') '3  1000000  1000000  1000000'
        write(ITA3,'(a)') '  '
        write(ITA3,'(a)')'patch_light source patch'
        write(ITA3,'(a)')'0'
        write(ITA3,'(a)')'0'
        write(ITA3,'(a)') '4  0.  0.  1.  13.39'
        call ERPFREE(ITA3,ISTAT)
        skydone=.true.
      else

C Generate sky command use a sun for all skys except for daylight factors.
        if (RIFPURP(ISCENEFOC)(1:8).eq.'External'.or.
     &          RIFPURP(ISCENEFOC)(1:8).eq.'Internal'.or.
     &          RIFPURP(ISCENEFOC)(1:5).eq.'Glare') then
          call settime(IRM,IRD,XRT)
          write(outs,'(a,2i3,f6.2,a,f5.2,2(a,f7.1),a)')'gensky',IRM,IRD,
     &          XRT,' +s -g ',rgrfl,' -a ',XLAT,' -o ',-XLON,' -m 0.0'
        elseif (RIFPURP(ISCENEFOC)(1:8).eq.'Day_fact') then
          write(outs,'(a,f5.2,2(a,f7.1),a)') 'gensky 6 20 12.0 -c -g ',
     &                        rgrfl,' -a ',XLAT,' -o ',-XLON,' -m 0.0'
        elseif (RIFPURP(ISCENEFOC)(1:8).eq.'Coupling') then

C gendaylit -ang 60 0 -L QDIRILL QDIFILL
          write(outs,'(a,f5.2)')
     &                     'gendaylit -ang 60 0 -L 805 100 -g ',rgrfl

        elseif (RIFPURP(ISCENEFOC)(1:7).eq.'Sun_pos') then

C Pick start and end time.
        endif

C Now call Radiance with command stored in variable 'outs'.
        call wrtsky(outs)
        call RRSKY(ITA2,rskyfil,ga,IER)
        if (RIFPURP(ISCENEFOC)(1:8).eq.'External') then
          call RADPAR('av',ga)
        elseif (RIFPURP(ISCENEFOC)(1:8).eq.'Internal') then
          xga=ga/10.
          call RADPAR('av',xga)
        endif
      endif

C Create inside and outside files, first open databases.
      call opendb(ier)
      ftr=0.92
      fict=.false.
      call mkriofil(ftr,fict,'s',IER)
      IFC=3
      call mkrif(ita2,RIFNAME(ISCENEFOC),IFC,0,ier)
      if (NBSRIF(ISCENEFOC).eq.1) then
        call mkrif(ita2,LBSRIF(ISCENEFOC),IFC,1,ier)
      endif

C Update rcf file and configuration file.
      ICHK=3
      call RADCFGOUT(ICHK)

C Generate new octree.
      call touchrif(RIFNAME(ISCENEFOC))
      if (NBSRIF(ISCENEFOC).gt.0) then
        call touchrif(LBSRIF(ISCENEFOC))
      endif

C If scene purpose is coupling or daylight coefficients then return.
      if (RIFPURP(ISCENEFOC)(1:8).eq.'Coupling') then
        return
      elseif (RIFPURP(ISCENEFOC)(1:8).eq.'Day_coef') then
        return
      endif

C Continue and run radiance simulation?
      dok=.true.
      h(1)='You can start the visual simulation at this point by'
      h(2)='answering yes. If you say no you can start the simulation'
      h(3)='later. Note the simulation can take several minutes, if '
      h(4)='hours to complete. '
      call ASKOK('Scene description is now complete.',
     &           'Proceed with simulation?',OK,dok,4)
      if (OK) then
        if (RIFPURP(ISCENEFOC)(1:8).eq.'External'.or.
     &      RIFPURP(ISCENEFOC)(1:8).eq.'Internal') then

C Generate default view information and then the image.
          call defview
          call genimage(1)
        elseif (RIFPURP(ISCENEFOC)(1:5).eq.'Glare') then

C Generate <<? default view information ?>> and then the image.
          call defview
          call genimage(2)
          call getglr
          call dispimage(2)
        elseif (RIFPURP(ISCENEFOC)(1:8).eq.'Day_fact') then

C Calculate the daylight factors and then diplay them via dfgridlbl.
          call getdf
          call DFGRIDLBL('d')
        endif
      endif

      return
      end

C ********************** simscene **********************
C simscene simulates daylight coefficients and coupling (called from bps)

      SUBROUTINE simscene
#include "building.h"
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      COMMON/FILEP/IFIL
      common/uhome/upath
      common/expath/runpath,pathtype

      common/sky1/rgrfl,isky,irdoy,rtime,iryear
      common/e2rf/rambfil,optnfil
      common/rad1/rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      common/raddn/skydone,outdone,indone,misdone,vewdone,glzdone
      common/raddata/SCENE(MCOM+1),RIFNAME(MCOM+1),SCENERT(MCOM+1),
     &               RIFDESC(MCOM+1),RIFPURP(MCOM+1)
      common/raddata2/NSCENE,ISCENEFOC
      common/raddata3/NBSRIF(MCOM+1),LBSRIF(MCOM+1)
      common/cmddata/zone,aim,act
      common/radgrid/LDFGRID

      character rambfil*72,optnfil*72
      character*72 rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      character SCENE*28,RIFNAME*72,SCENERT*28,RIFDESC*72,RIFPURP*12
      character outs*124,doit*124,doitl*256,tfile*72
      character zone*16,aim*12,act*72,LBSRIF*72
      character QT*1
      character*72 LDFGRID,LTMPFL,LTMPFA,rn,upath
      character runpath*72,pathtype*24

      dimension npz(8),alt(8),azim(8),solid(8)

      logical skydone,outdone,indone,misdone,vewdone,glzdone
      LOGICAL XST,unixok
      integer lnrp  ! length of run path

      data npz/30,60,84,108,126,138,144,145/
      data alt/6.,18.,30.,42.,54.,66.,78.,90./
      data azim/12.,12.,15.,15.,20.,30.,60.,0./
      data solid/13.39,13.39,13.39,13.39,13.39,13.39,13.39,13.39/

      QT=CHAR(39)
      ITA1=IFIL+6
      ITA2=IFIL+7
      ITA3=IFIL+10
      call isunix(unixok)
      lnrp=lnblnk(runpath)

C Simulate scene as defined by aim argument.
      if (RIFPURP(ISCENEFOC)(1:8).eq.'Coupling') then

C Read from transfer file defined as the argument for -act from
C the users home folder.
        if(unixok)then
          write(doit,'(6a)') 'cp ',upath(1:lnblnk(upath)),'/',
     &               act(1:lnblnk(act)),'  ',runpath(1:lnrp)
        else
          write(doit,'(6a)') 'copy /y ',upath(1:lnblnk(upath)),'/',
     &               act(1:lnblnk(act)),'  ',runpath(1:lnrp)
        endif
        call runit(doit,'-')
        ier=0
        write (LTMPFL,'(a,a)') runpath(1:lnrp),act(1:lnblnk(act))
        call FPOPEN(ITA1,ISTAT,1,1,LTMPFL)
        if (ier.ne.0) then 
          call usrmsg('Cannot open transfer file:',act,'F')
          return
        endif
        CALL STRIPC(ITA1,OUTS,0,ND,0,'transfer file',IER)
        if (ier.ne.0) then 
          call usrmsg('Cannot read transfer file:',act,'F')
          return
        endif
        K=0
        call EGETWR(OUTS,K,RSALT,0.,90.,'F','Solar alt',IER)
        call EGETWR(OUTS,K,RSAZI,-180.,180.,'W','Sol azi',IER)
        call EGETWR(OUTS,K,QDIR,0.,1250.,'W','Dir solar',IER)
        call EGETWR(OUTS,K,QDIF,0.,1250.,'W','Diff solar',IER)
        call EGETWI(OUTS,K,IBLNDS,0,1,'W','Blinds state',IER)

C Check solar position and radiation.
        QDIRH=QDIR*esind(RSALT/57.296)

C Create sky command and sky.
        if (RSALT.gt.5.0) then
          write(outs,'(a,2f7.1,a,2f7.1,a,f5.2)')'gendaylit -ang ',RSALT,
     &                         RSAZI,' -W ',QDIR,QDIF,' -g ',rgrfl
        else
          if (QDIR.gt.0) then
            write(outs,'(a,2f7.1,2(a,f7.1),a,f5.2)')'gensky -ang ',
     &                RSALT,RSAZI,' -B ',QDIF,' -R ',QDIRH,' -g ',rgrfl
          else
            write(outs,'(a,2f7.1,a,f7.1,a,f5.2)')'gensky -ang ',RSALT,
     &                                RSAZI,' -c -B ',QDIF,' -g ',rgrfl
          endif
        endif
        call wrtsky(outs)

C Recreate octree, setting rtrace options, and run rtrace.
        if (IBLNDS.ne.0.and.NBSRIF(ISCENEFOC).eq.0) then

C Error can't simulate switched blinds.
C          call usrmsg('Cannot simulate switched blinds.','  ','F')
          write(outs,'(a,a)')
     &  'In .rcf: Alternative .rif for ',
     &  '"replacement properties (TMC)" missing!'
          call usrmsg(outs,'  ','F')
        endif
        if (IBLNDS.eq.0) then
          rn=RIFNAME(ISCENEFOC)
        else
C                         Here we need logic to be able to call as many different .rifs
C                         as there are control periods in the .tmc ...
C          NBPONT(ICOMP,ITMC) ! the current control period
C          NBCTMC() ! number of control periods
          rn=LBSRIF(ISCENEFOC)
        endif

C Rebuild.
        call touchrif(rn)

C Run rtrace. << ?? what about pathtype?? >>
        write(doitl,'(4a,1x,9a)') 'cd ',runpath(1:lnrp),
     &      '; rtrace -ov -I -h @',
     &      optnfil(1:lnblnk(optnfil)),octfil(1:lnblnk(octfil)),
     &       ' < ',LDFGRID(1:lnblnk(LDFGRID)),' | rcalc -e ',QT,
     &       '$1=179*(0.265*$1+0.670*$2+0.065*$3)',QT,' >> ',
     &                                               act(1:lnblnk(act))
        call runit(doitl,'-')

C Copy transfer file back to users homedir (bps is expecting it to be there).
        call isunix(unixok)
        if(unixok)then
          write(doit,'(5a)') 'cp ',runpath(1:lnrp),
     &                act(1:lnblnk(act)),'  ',upath(1:lnblnk(upath))
        else
          write(doit,'(5a)') 'copy /y ',runpath(1:lnrp),
     &                act(1:lnblnk(act)),'  ',upath(1:lnblnk(upath))
        endif
        call runit(doit,'-')

C Daylight coefficients.
      elseif (RIFPURP(ISCENEFOC)(1:8).eq.'Day_coef') then

C Do for all blind states.
        IBLND=0
 1234   do 123 IPTCH=1,145

C Search for existing 'sky' file. (If found delete)
          write(tfile,'(a,a)')runpath(1:lnrp),
     &                        rskyfil(1:lnblnk(rskyfil))
          INQUIRE (FILE=tfile,EXIST=XST)
          if(XST)then
            call FPOPEN(ITA3,ISTAT,1,0,tfile)
            call EFDELET(ITA3,ISTAT)
          endif
          call FPOPEN(ITA3,ISTAT,1,2,tfile)
          write(ITA3,'(a,i4)') '# sky patch: ',IPTCH
          write(ITA3,'(a)') '  '
          write(ITA3,'(a)') 'void  light  patch_light'
          write(ITA3,'(a)') '0 '
          write(ITA3,'(a)') '0 '
          write(ITA3,'(a)') '3  1000000  1000000  1000000'
          write(ITA3,'(a)') '  '

C Calculate patch direction vector (location).
          if(IPTCH.ge.1.and.IPTCH.le.30) nzone = 1
          if(IPTCH.ge.31.and.IPTCH.le.60) nzone = 2
          if(IPTCH.ge.61.and.IPTCH.le.84) nzone = 3
          if(IPTCH.ge.85.and.IPTCH.le.108) nzone = 4
          if(IPTCH.ge.109.and.IPTCH.le.126) nzone = 5
          if(IPTCH.ge.127.and.IPTCH.le.138) nzone = 6
          if(IPTCH.ge.139.and.IPTCH.le.144) nzone = 7
          if(IPTCH.eq.145) nzone = 8
          if(nzone.eq.8) then
            xp = 0.0
            yp = 0.0
            zp = 1.0
          elseif(nzone.eq.1) then
            aazim = azim(nzone)*(IPTCH - 1)
            xp = ecosd(aazim)*ecosd(alt(nzone))
            yp = esind(aazim)*ecosd(alt(nzone))
            zp = esind(alt(nzone))
          else
            aazim = azim(nzone)*((IPTCH - npz(nzone-1)) - 1)
            xp = ecosd(aazim)*ecosd(alt(nzone))
            yp = esind(aazim)*ecosd(alt(nzone))
            zp = esind(alt(nzone))
          endif

C Debug
C          write(6,*) 'IPTCH',' Xp',' Yp',' Zp',' azim',' alt'
C          write(6,*) IPTCH,' ',xp,' ',yp,' ',zp,' ',aazim,' ',alt	   
C End Debug

          write(ITA3,'(a)') 'patch_light source patch'
          write(ITA3,'(a)') '0'
          write(ITA3,'(a)') '0'
          write(ITA3,'(a,4f10.6)') '4 ',xp,yp,zp,solid(nzone)
          call ERPFREE(ITA3,ISTAT)
          skydone=.true.

C Generate new octree.
          if (IBLND.eq.0) then
            rn=RIFNAME(ISCENEFOC)
          else
            rn=LBSRIF(ISCENEFOC)
          endif

C Recreate octree and get current file names.
          call touchrif(rn)
          write(outs,'(2a,i3)')' Daylight coefficient: ',
     &                         'Run oconv for patch ',IPTCH
          call edisp(iuout,outs)

C Check for output file only for first patch.
          if (IPTCH.eq.1) then

C Create temporary file (format: .PID.cmd)
            call esppid(ipid)
            write(outs,'(a,i7,a)') runpath(1:lnrp),ipid,'.dcf'
            call st2file(outs,LTMPFA)
            XST=.FALSE.
            INQUIRE (FILE=LTMPFA(1:lnblnk(LTMPFA)),EXIST=XST)
            if(XST)then
              call FPOPEN(ITA2,ISTAT,1,0,LTMPFA)
              call EFDELET(ITA2,ISTAT)
            endif
            call FPOPEN(ITA2,ISTAT,1,2,LTMPFA)
            write(ITA2,'(a)')'# Sensor illuminance for daylight coefs.'
            write(ITA2,'(a)')'# Temporary data file.'
            call ERPFREE(ITA2,ISTAT)
          endif

C Run rtrace.
         write(outs,98)' Daylight coefficient: ',
     &                      'Run rtrace for patch ',IPTCH
 98      format(2a,i3)

          write(doitl,'(4a,1x,9a)') 'cd ',runpath(1:lnrp),
     &      '; rtrace -ov -I -h @',
     &      optnfil(1:lnblnk(optnfil)),octfil(1:lnblnk(octfil)),
     &       ' < ',LDFGRID(1:lnblnk(LDFGRID)),' | rcalc -e ',QT,
     &       '$1=(0.265*$1+0.670*$2+0.065*$3)/(1000000*2*PI/145.)',
     &                               QT,' >>',LTMPFA(1:lnblnk(LTMPFA))
          call runit(doitl,'-')

C Display progress...
          if (IPTCH.eq.35) then
            call edisp(IUOUT,'Calculation 25% complete.')
          elseif (IPTCH.eq.70) then
            call edisp(IUOUT,'Calculation 50% complete.')
          elseif (IPTCH.eq.105) then
            call edisp(IUOUT,'Calculation 75% complete.')
          endif
 123    continue

C Read in daylight coefficients and save to cgc file.
        ISET=IBLND+1
        call RDCFTMP(LTMPFA,ISET)

C Remove temporary files.
        XST=.FALSE.
        INQUIRE (FILE=LTMPFA(1:lnblnk(LTMPFA)),EXIST=XST)
        if(XST)then
          call FPOPEN(ITA2,ISTAT,1,0,LTMPFA)
          call EFDELET(ITA2,ISTAT)
        endif
         
        call edisp(IUOUT,'Daylight coefficient set complete')

C Do other blind states.
        if (NBSRIF(ISCENEFOC).gt.0) then
          IBLND=IBLND+1
          if (IBLND.le.NBSRIF(ISCENEFOC)) then
            call edisp(IUOUT,'Calculating next blind state.')
            goto 1234
          endif
        endif
      endif

      return
      end


C ********************** settime **********************
C settime - user choice of standard times for sky generation

      SUBROUTINE settime(IRM,IRD,XRT)

      common/pophelp/h(60)
      common/sky1/rgrfl,isky,irdoy,rtime,iryear

      character H*72

C Ask winter am/pm spring am/pm summer am/pm
      H(1)='Pick a season/ time for the sky. ' 
      CALL EASKABCD('A scene is created for a specific day and time.',
     &   'Select one from these defaults:','winter AM','winter PM',
     &        'summer AM','summer PM',IWDT,1)
      if(IWDT.eq.1)then
        irdoy=15
        rtime=10.0
      elseif(IWDT.eq.2)then
        irdoy=15
        rtime=15.0
      elseif(IWDT.eq.3)then
        irdoy=160
        rtime=9.0
      elseif(IWDT.eq.4)then
        irdoy=160
        rtime=15.0
      endif
      CALL EDAYR(irdoy,IRD,IRM)
      XRT=rtime

      return
      end

C ********************** touchrif **********************
C touchrif generates an options file based on information 
C generated by rad -t after removing current octree.

      SUBROUTINE touchrif(RIFFILE)
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      COMMON/FILEP/IFIL
      common/expath/runpath,pathtype
      common/rad1/rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil

      character*72 rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      character doit*124,RIFFILE*72,runpath*72,pathtype*24
      integer lnrp  ! length of run path

C Read current rif file.
      ITA2=IFIL+7
      ITA3=IFIL+10
      call RRIF(ITA2,ITA3,RIFFILE,'s',IERR)
      lnrp=lnblnk(runpath)
      
C Remove octree to force rebuild as radiance sometimes gets this wrong.
      write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &                   '; rm -f ',octfil(1:lnblnk(octfil))
      call runit(doit,'-')

C Run rad in 'touch up' mode.
      write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &                   '; rad -t ',RIFFILE(1:lnblnk(RIFFILE))
      call edisp(iuout,'Radiance feedback is displayed in xterm.')
      call runit(doit,'-')
      
      return
      end

C ********************** defview **********************
C defview generates a new default view.

      SUBROUTINE defview
#include "building.h"
#include "prj3dv.h"

      COMMON/FILEP/IFIL

      common/raddata/SCENE(MCOM+1),RIFNAME(MCOM+1),SCENERT(MCOM+1),
     &               RIFDESC(MCOM+1),RIFPURP(MCOM+1)
      common/raddata2/NSCENE,ISCENEFOC
      common/raddata3/NBSRIF(MCOM+1),LBSRIF(MCOM+1)
      common/e2rv/vewcmds(20),rvewsh(20),indxvew,ipckvew
      COMMON/RAY5/ZCOG(MCOM,3),XMN,YMN,ZMN,XMX,YMX,ZMX
      COMMON/RAY5OB/OXMN,OYMN,OZMN,OXMX,OYMX,OZMX

      common/initv/initvt,EYEMI(3),VIEWMI(3),ANGI

      character SCENE*28,RIFNAME*72,SCENERT*28,RIFDESC*72,RIFPURP*12
      character vewcmds*124,rvewsh*10,LBSRIF*72

      ITA2=IFIL+7

C External view point.
      if (RIFPURP(ISCENEFOC)(1:8).eq.'External') then
C Create a default view, set file name, set bounds for slightly
C smaller than the ground disk. Save off zone bounds before
C adding in the ground disk.
        OXMN=XMN
        OYMN=YMN
        OZMN=ZMN
        OXMX=XMX
        OYMX=YMX
        OZMX=ZMX
        XD=(XMX-XMN)**2 + (YMX-YMN)**2
        DD=SQRT(XD)*1.5
        cx=XMN+((XMX-XMN)/2.)
        cy=YMN+((YMX-YMN)/2.)
        XMN=cx-DD
        XMX=cx+DD
        YMN=cy-DD
        YMX=cy+DD
        ZMN=ZMN
        ZMX=DD
        rvpx=-100.
        rvpy=-100.
        rvpz=100.
        if(initvt.eq.1)then
          rvpx=EYEMI(1)
          rvpy=EYEMI(2)
          rvpz=EYEMI(3)
        endif
        call ln2az(rvpx,rvpy,rvpz,VIEWM(1),VIEWM(2),VIEWM(3),
     &                                               azim,elev)
        call ang3vtx(OXMN,OYMN,OZMN,EYEM(1),EYEM(2),EYEM(3),OXMX,
     &             OYMX,OZMX,eang)
        angv=eang*1.2
        angh=eang*1.2

        call AZ2UV(azim,elev,vdx,vdy,vdz)
        write(vewcmds(1),'(a,3F9.3,a,3F8.4,a,F6.1,a,F6.1,a)') 
     &       '-vtv -vp ',rvpx,rvpy,rvpz,' -vd ',vdx,vdy,vdz,
     &       ' -vu 0 0 1 -vh ',angh,' -vv ',angv,' -vs 0 -vl 0 '
        rvewsh(1) = 'def'
        indxvew=1
        ipckvew=1

      elseif (RIFPURP(ISCENEFOC)(1:8).eq.'Internal') then

C Default internal view at max X average Y and Z, looking in -x dir.
        indxvew=0
        ipckvew=-1
      else
        indxvew=0
        ipckvew=-1
      endif

C Update rif file.
      IFC=3
      IER=0
      call MKRIF(ITA2,RIFNAME(ISCENEFOC),IFC,0,IER)
      if (NBSRIF(ISCENEFOC).eq.1) then
        call mkrif(ita2,LBSRIF(ISCENEFOC),IFC,1,ier)
      endif

      return
      end


C ********************** genimage **********************
C genimage generates an image to screen or file.
C ITP =1 - image only; =2 - glare info to display on image.
      SUBROUTINE genimage(ITP)
#include "building.h"
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      COMMON/FILEP/IFIL
      common/pophelp/h(60)

      common/expath/runpath,pathtype
      COMMON/C4/XLAT,XLON

      common/sky1/rgrfl,isky,irdoy,rtime,iryear
      common/rad1/rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      common/rad2/mono,intext,ifocz
      common/e2rq/indrcb,itrack,imgqua,detlvl,llvar,penumb
      common/radrp/ipicx
      common/raddata/SCENE(MCOM+1),RIFNAME(MCOM+1),SCENERT(MCOM+1),
     &               RIFDESC(MCOM+1),RIFPURP(MCOM+1)
      common/raddata2/NSCENE,ISCENEFOC
      common/raddata3/NBSRIF(MCOM+1),LBSRIF(MCOM+1)
      common/e2rv/vewcmds(20),rvewsh(20),indxvew,ipckvew

      character*72 rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      character tpic*72,tpicd*72,tgif*72,tgifd*72
      character SCENE*28,RIFNAME*72,SCENERT*28,RIFDESC*72,RIFPURP*12
      character vewcmds*124,rvewsh*10,pf*72,h*72,outs*124,ltmp*72
      character doit*256,LBSRIF*72,runpath*72,pathtype*24
      character imgqua*6,detlvl*6,llvar*6,penumb*5
      integer lnrp  ! length of run path

      logical XST,anim,unixok
      CHARACTER*3 NMTHNM(12)
      DATA NMTHNM/'Jan','Feb','Mar','Apr','May','Jun','Jul',
     &'Aug','Sep','Oct','Nov','Dec'/

      ITA2=IFIL+7
      anim=.false.
      lnrp=lnblnk(runpath)

      if (ITP.eq.1) then

C Ask if an animation required.
        H(1)='Rendering can only be for one instant in time or'
        H(2)='at intervals during a period of a day.  You can '
        H(3)='adjust the parameters needed to create a set of'
        H(4)='images which can be combined to form an amimation.'
        CALL EASKAB(' ',' Image(s):','single time instance',
     &     'sequence',IWDA,4)
        if(iwda.eq.2)then
          anim = .true.
          IWDQ=2
        else
          if(mono.gt.0)then
            H(1)='Rendering can only be directed to screen on colour'
            H(2)='monitors.  You can adjust the visualisation '
            H(3)='parameters interactively and a summary of commands'
            H(4)='which Radiance understands is provided. '
            H(5)='  '
            H(6)='If running on Windows you should choose file option.'
            CALL EASKAB(' ','Image rendering to:','screen','file',
     &        IWDQ,6)
          else
            IWDQ=2
          endif
        endif
      else

C If glare put it to file.
        IWDQ=2
      endif
      if(IWDQ.eq.1)then
      
C If in unix then use interactive rendering. If Native Windows do
C not try and display.
        call isunix(unixok)
        if (ipckvew.eq.-1) then 
          if(unixok)then
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &          '; rad -e -o x11 ',
     &          RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC))),' &'
          else
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &          '; rad -e ',
     &          RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC))),' &'
          endif
        elseif (ipckvew.eq.0) then 
          if(unixok)then
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &          '; rad -e -o x11 ',
     &          RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC))),' &'
          else
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &          '; rad -e ',
     &          RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC))),' &'
          endif
        else
          if(unixok)then
            write(doit,'(7a)') 'cd ',runpath(1:lnrp),
     &           '; rad -e -o x11 -v ',
     &           rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),' ',
     &           RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC))),' &'
          else
            write(doit,'(7a)') 'cd ',runpath(1:lnrp),
     &           '; rad -e -v ',
     &           rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),' ',
     &           RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC))),' &'
          endif
        endif
        write(6,*) doit
        call runit(doit,'-')

C Display helpful messages while the image is rendering.
        call edisp(iuout,'Helpful rview commands:  ')
        call edisp(iuout,' All commands can be shortened, to use ')
        call edisp(iuout,' just type in the `rview` window.')
        call edisp(iuout,'  ')
        call edisp(iuout,' aim      - adjust the view direction.')
        call edisp(iuout,' exposure - adjust exposure:')
        call edisp(iuout,'           if `e +1` then increase 1 f stop.')
        call edisp(iuout,'           if `e 1` then exposure averaged.')
        call edisp(iuout,' last     - restore last view.  ')
        call edisp(iuout,' last [file] - restore view from file.')
        call edisp(iuout,' view     - save current view info > file.')
        call edisp(iuout,' write    - save current image to file.')
        call edisp(iuout,' quit     - give up preview. ')
        call edisp(iuout,'  ')
        call edisp(iuout,'For more info see the radiance manual. ')
      else
        if(anim)then

C Confirm end time and increment. ATIMST is the start time (real) and
C ITST is the start time (int).
          call edisp(iuout,' ')
          call edisp(iuout,' Date & time at start of animation...')
          iardoy=irdoy
          CALL EDAYR(iardoy,IADO,IAMO)
          ATIMEST=4.0
          CALL ASKTIM(2,1,IAMO,IADO,iardoy,ATIMEST,ITST,IER)

C Ask for end time of the animation.
          H(1)='The end of the animation is assumed to be on the same'
          H(2)='day and must be less than 24.0'
          ATIMEFN = ATIMEST + 1.0
          CALL EASKR(ATIMEFN,' ',' End time of the animation? ',
     &      ATIMEST,'W',24.0,'W',0.2,'end time of anim',IER,2)

C Figure out the increment.
          H(1)='The increment is usually set as a compromise between'
          H(2)='the visual jump between views and computation time. '
          CALL EASKATOG('Interval between views:',' ','one min',
     &      'five min','ten min','15 min','20 min','30 min','cancel',
     &      IWT,2)
          if(IWT.EQ.1)then
            DT=0.016666
          elseif(IWT.EQ.2)then
            DT=0.083333
          elseif(IWT.EQ.3)then
            DT=0.166666
          elseif(IWT.EQ.4)then
            DT=0.25
          elseif(IWT.EQ.5)then
            DT=0.33333
          elseif(IWT.EQ.6)then
            DT=0.5
          elseif(IWT.EQ.7)then
            return
          endif

C Up the image quality if low.
          if(imgqua(1:3).eq.'Low')imgqua = 'Medium'

C Size of the images (set IFP to double so can filter).
          H(1)='The image frame size is a compromise between the'
          H(2)='visual detail and and computation time. '
          CALL EASKATOG('Image frame size (pixels):',' ','240',
     &      '320','400','500','600','700','cancel',IWP,2)
          if(IWP.EQ.1)then
            ipicx=240
          elseif(IWP.EQ.2)then
            ipicx=320
          elseif(IWP.EQ.3)then
            ipicx=400
          elseif(IWP.EQ.4)then
            ipicx=500
          elseif(IWP.EQ.5)then
            ipicx=600
          elseif(IWP.EQ.6)then
            ipicx=700
          elseif(IWP.EQ.7)then
            return
          endif

C Loop from start and increment until at or past the finish time.
          idone=1
          CURT=ATIMEST
          do while (idone.ne.0)
            write(outs,'(a,2i3,f7.3,a,f5.2,2(a,f7.1),a)')'gensky',IAMO,
     &        IADO,CURT,' +s -g ',rgrfl,' -a ',XLAT,' -o ',-XLON,
     &        ' -m 0.0'
            CALL wrtsky(outs)

C We will need pic & gif file for this time. Write out and then use
C sdelim with a N to remove spaces.
            write(tpic,'(a,2i3,f6.3,a)') runpath(1:lnrp),
     &        IAMO,IADO,CURT,'.pic'
            call sdelim(tpic,tpicd,'N',IW)
            write(tgif,'(a,2i3,f6.3,a)') runpath(1:lnrp),
     &        IAMO,IADO,CURT,'.gif'
            call sdelim(tgif,tgifd,'N',IW)

C If animation use a standard name for pic file (which is going to
C be converted into a timestamp named gif file. Any existing pic
C file should be removed.
            if (ipckvew.gt.0) then
              write(pf,'(5a)') runpath(1:lnrp),
     &          picfil(1:lnblnk(picfil)),'_',
     &          rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.pic'
            else
              write(pf,'(3a)') runpath(1:lnrp),
     &          picfil(1:lnblnk(picfil)),'_X.pic'
            endif
            CALL ERPFREE(ITA2,ISTAT)
            INQUIRE (FILE=pf,EXIST=XST)
            if(XST)then
              call ERPFREE(ITA2,ISTAT)
              call FPOPEN(ITA2,ISTAT,1,1,pf)
              call EFDELET(ITA2,ISTAT)
            endif

C Save changes to RIF file
            IFC=3
            call MKRIF(ITA2,RIFNAME(ISCENEFOC),IFC,0,IER)
            if (NBSRIF(ISCENEFOC).eq.1) then
              call mkrif(ita2,LBSRIF(ISCENEFOC),IFC,1,ier)
            endif

C call rad to create image(s) based on current setting of ipckvew.
            if (ipckvew.eq.-1) then 
              write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &          '; rad -e ',
     &          RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC)))
            elseif (ipckvew.eq.0) then 
              write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &          '; rad -e ',
     &          RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC)))
            else
              write(doit,'(6a)') 'cd ',runpath(1:lnrp),
     &        '; rad -e -v ',
     &        rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),
     &        ' ',RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC)))
            endif
            write(6,*) doit
            write(outs,'(2a,i3,F6.2)') 'Currently working on...',
     &        NMTHNM(IAMO),IADO,CURT
            call edisp(iuout,outs)
            call runit(doit,'-')

C Generate a label and put into tpic.
            write(doit,'(2a,i3,F6.2,4a)') 'psign -h 18 ',NMTHNM(IAMO),
     &        IADO,CURT,' | pcompos ',pf(1:lnblnk(pf)),' 0 0 - 2 2 > ',
     &        tpicd(1:lnblnk(tpicd))
            write(6,*) doit
            call runit(doit,'-')

C Generate command to convert to a gif.
            write(doit,'(4a)') 'ra_gif ',tpicd(1:lnblnk(tpicd)),' ',
     &        tgifd(1:lnblnk(tgifd))
            write(6,*) doit
            call runit(doit,'-')

C Increment the current time.
            CURT=CURT+DT
            if(CURT.gt.ATIMEFN)idone=0
          end do
        else

C See if there is an existing pic file by this name.
          if (ipckvew.gt.0) then
            write(pf,'(5a)') runpath(1:lnrp),
     &        picfil(1:lnblnk(picfil)),'_',
     &        rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.pic'
          else
            write(pf,'(3a)') runpath(1:lnrp),
     &        picfil(1:lnblnk(picfil)),'_X.pic'
          endif
          CALL ERPFREE(ITA2,ISTAT)
          INQUIRE (FILE=pf,EXIST=XST)
          if(XST)then
            H(1)='The image processing tends to `hang` when '
            H(2)='trying to overwrite an existing image. '
            write(outs,'(a,a)') 'There is an existing picture file ',
     &        pf(1:lnblnk(pf))
            CALL EASKABC(outs,'Do you want to: ','overwrite',
     &        'choose another name','cancel',IWR,2)
            if(IWR.eq.3)then
              return
            elseif(IWR.eq.2)then
              H(1)='Root name for pictures created with `rad`'
 1111         ltmp = picfil
              CALL EASKS(ltmp,
     &          ' Picture root name (modify slightly) ? ',
     &          ' ',72,'xx','picture root file name',IER,1)
              if(ltmp(1:2).ne.'  ') then
                picfil = ltmp
              else
                goto 1111
              endif
              IFC=3
              call MKRIF(ITA2,RIFNAME(ISCENEFOC),IFC,0,IER)
              if (NBSRIF(ISCENEFOC).eq.1) then
                call mkrif(ita2,LBSRIF(ISCENEFOC),IFC,1,ier)
              endif
            elseif(IWR.eq.1)then

C Set file name including path and open.
              call ERPFREE(ITA2,ISTAT)
              call FPOPEN(ITA2,ISTAT,1,1,pf)
              call EFDELET(ITA2,ISTAT)
            endif
          endif
        endif
        if (ipckvew.eq.-1) then 
          write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &       '; rad -e ',
     &       RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC)))
        elseif (ipckvew.eq.0) then 
          write(doit,'(4a)') 'cd ',runpath(1:lnrp),
     &       '; rad -e ',
     &       RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC)))
        else
          write(doit,'(6a)') 'cd ',runpath(1:lnrp),
     &      '; rad -e -v ',rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),
     &      ' ',RIFNAME(ISCENEFOC)(1:lnblnk(RIFNAME(ISCENEFOC)))
        endif
        write(6,*) doit
        call edisp(iuout,'Look in the text window for progress.')
        call runit(doit,'-')
        if (ITP.eq.1)call dispimage(1)
      endif

      return
      end

C ********************** dispimage **********************
C dispimage displays an image file to screen.
C ITP =1 - image only; =2 - glare info to display on image.
C Assumes that the path to the image is given.

      SUBROUTINE dispimage(ITP)
      
      integer lnblnk  ! function definition

      COMMON/FILEP/IFIL
      COMMON/OUTIN/IUOUT,IUIN
      COMMON/SPAD/MMOD,LIMIT,LIMTTY
      integer menuchw,igl,igr,igt,igb,igw,igwh
      common/VIEWPX/menuchw,igl,igr,igt,igb,igw,igwh

      common/rad1/rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      common/rad2/mono,intext,ifocz
      common/expath/runpath,pathtype

      common/e2rv/vewcmds(20),rvewsh(20),indxvew,ipckvew

      character*72 rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      character doit*124,pf*72,gf*72,ugrf*72,ltmp*72
      character vewcmds*124,rvewsh*10,outs*124,outstr*124
      character runpath*72,pathtype*24
      integer lnrp  ! length of run path
      
      dimension UGRV(72),UGRANG(72)
#ifdef OSX
      integer igwid,igheight  ! for use with axiscale
      integer iix1,iiy1,iix2,iiy2
#else
      integer*8 igwid,igheight  ! for use with axiscale
      integer*8 iix1,iiy1,iix2,iiy2
#endif
      
      logical XST,unixok

C Generate picture and glare file names.
      lnrp=lnblnk(runpath)
      if (ipckvew.gt.0) then
        write(pf,'(a,a,a,a)') picfil(1:lnblnk(picfil)),'_',
     &                rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.pic'
        write(gf,'(a,a,a,a)') picfil(1:lnblnk(picfil)),'_',
     &                rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.glr'
      else
        write(pf,'(a,a)') picfil(1:lnblnk(picfil)),'_X.pic'
        write(gf,'(a,a)') picfil(1:lnblnk(picfil)),'_X.glr'
      endif

      if (ITP.eq.1) then
        call isunix(unixok)
        if(unixok)then
          call edisp(iuout,' Starting ximage with the commands:')
          if(mono.eq.0)then
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &       '; ximage -m ',pf(1:lnblnk(pf)),' &'
          elseif(mono.eq.1)then
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &       '; ximage -b ',pf(1:lnblnk(pf)),' &'
          elseif(mono.eq.2)then
            write(doit,'(5a)') 'cd ',runpath(1:lnrp),
     &       '; ximage ',pf(1:lnblnk(pf)),' &'
          endif
          call runit(doit,'-')
        else
          call edisp(iuout,' ximage not available on Windows.')
        endif
      elseif (ITP.eq.2) then
      
C First display glare sources on image.
        write(doit,'(7a)') 'cd ',runpath(1:lnrp),
     &       '; xglaresrc ',pf(1:lnblnk(pf)),' ',gf(1:lnblnk(gf)),' &'
        call runit(doit,'-')

C Calculate UGR from glare file and display to screen.
        write (doit,'(7a)') 'cd ',runpath(1:lnrp),
     &      '; glarendx -t ugr -h ',gf(1:lnblnk(gf)),' > ',
     &      gf(1:lnblnk(gf)),'.ugr'
        call runit(doit,'-')
        
C Read file then display graph.
C Check for daylight factor results.
        write (ugrf,'(2a)') gf(1:lnblnk(gf)),'.ugr'
        write (ltmp,'(2a)') 
     &             runpath(1:lnrp),ugrf(1:lnblnk(ugrf))
        ITA1 = IFIL+6
        call ERPFREE(ITA1,ISTAT)
        call FINDFIL(ltmp,XST)
        if(XST)then
          call edisp (iuout,'Angle  UGR')
          XMIN=0.0
          XMAX=0.0
          YMIN=0.
          YMAX=1.0
          call FPOPEN(ITA1,ISTAT,1,1,ltmp)
          NUGR=0
          if(ISTAT.eq.0)then
  43        CALL STRIPC(ITA1,OUTSTR,0,ND,0,'UGR results',IFER)
            if (IFER.eq.0.and.NUGR.lt.72) then
              NUGR=NUGR+1
              K=0
              CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','angle',IER)
              UGRANG(NUGR)=-1.*XTMP
              CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','UGR value',IER)
              UGRV(NUGR)=XTMP
              xmin=amin1(xmin,UGRANG(NUGR))
              xmax=amax1(xmax,UGRANG(NUGR))
              ymin=amin1(ymin,UGRV(NUGR))
              ymax=amax1(ymax,UGRV(NUGR))
              write (outs,'(f6.1,f6.2)') UGRANG(NUGR),UGRV(NUGR)
              call edisp (iuout,outs)
              goto 43
            endif
          endif
          call ERPFREE(ITA1,ISTAT)
          call edisp (iuout,'Note: -ive angle to left of view center.')
          if (MMOD.eq.8) then
            CALL startbuffer()
            call win3d(menuchw,8,8,5,3,igl,igr,igt,igb,igw,igwh)
            igw=igr-igl
            igwh=igb-igt
            igwid=igw
            igheight=igwh
            call axiscale(igwid,igheight,XMIN,XMAX,YMIN,YMAX,xsc,ysc,
     &                  sca,Xadd,Yadd)

C Stuff into static variables for later access and draw axis.
            call linescale(igl,Xadd,xsc,igb,Yadd,ysc)
            call vrtaxis(YMIN,YMAX,igl,igb,igt,Yadd,ysc,0,0,'UGR')
            call horaxis(XMIN,XMAX,igl,igr,igb,Xadd,xsc,0,
     &        'Degrees from view center')

C Draw values as a circle.
            call u2pixel(UGRANG(1),UGRV(1),iix1,iiy1)
            CALL ecirc(iix1,iiy1,3,1)
            do 10 I=2,NUGR
              call u2pixel(UGRANG(I),UGRV(I),iix2,iiy2)
              call edwline(iix1,iiy1,iix2,iiy2)
              CALL ecirc(iix2,iiy2,3,1)
              iix1=iix2
              iiy1=iiy2
 10         continue
            call forceflush()
          endif
        endif
      else
        return
      endif

      return
      end

C ********************** getglr **********************
C getglr recovers view information and runs glare calculation.

      SUBROUTINE getglr
#include "building.h"
      
      integer lnblnk  ! function definition

      COMMON/FILEP/IFIL
      common/expath/runpath,pathtype

      common/e2rv/vewcmds(20),rvewsh(20),indxvew,ipckvew
      common/rad1/rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      common/radv/rvpx,rvpy,rvpz,vdx,vdy,vdz,angh,angv,azim,elev
      common/raddata/SCENE(MCOM+1),RIFNAME(MCOM+1),SCENERT(MCOM+1),
     &               RIFDESC(MCOM+1),RIFPURP(MCOM+1)
      common/raddata2/NSCENE,ISCENEFOC

      character SCENE*28,RIFNAME*72,SCENERT*28,RIFDESC*72,RIFPURP*12
      character*72 rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      character vewcmds*124,rvewsh*10,rendopt*200
      character word*12,doit*300,ltmp*200,gf*72,pf*72,glst*4
      character runpath*72,pathtype*24

      ITA2 = IFIL+7
      ITA3 = IFIL+10

      IER=0
      call RRIF(ita2,ita3,RIFNAME(ISCENEFOC),'s',IER)

C Check if view info is in a file or kept in the rif file and set 
C glare angle (set minimum angle to 90 degrees).
      glang=90.
      if (vewcmds(ipckvew)(1:3).eq.'-vf') then
        K=4
        CALL EGETW(vewcmds(ipckvew),K,ltmp,'-','view file',IFLAG) 
        call RRVEW(ITA2,ltmp,IER)
        if ((angh/2.).gt.glang) glang=angh/2.
        if ((angv/2.).gt.glang) glang=angv/2.
      else
        K=0
        call CHITMS(vewcmds(ipckvew),ITMS)
        do 2112 IX=1,(ITMS-1)
          CALL EGETW(vewcmds(ipckvew),K,word,'-','view data',IFLAG)
          if (word(1:3).eq.'-vh'.or.word(1:3).eq.'-vv') then
            CALL EGETWR(vewcmds(ipckvew),K,ang,0.0,360.0,'W',
     &                                          'view angle',IFLAG)
            if ((ang/2.).gt.glang) glang=ang/2.
          endif
 2112   continue
      endif

C Round glang up to next multiple of ten degrees.
      test=(glang/10.0)-float(INT(glang/10.0))
      if (abs(test).ge.0.001) then
        glang=float(INT(glang/10.)+1)*10.
      endif

C Create strings of maximum angle and glare file name (based on pic name).
      write (word,'(i4)') INT(glang)
      K=0
      CALL EGETW(word,K,glst,'-','max glr angle',IFLAG)
      
C Read opt file so as rendering parameters can be set for rtrace.
      ltmp=' '
      rendopt=' '
      xval=-1.
      call RADPAR('dp',xval)
      write (ltmp,'(a,i4)') '-dp ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('ds',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -ds ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('dj',xval)
      if (xval.gt.0.) then
        write (6,*) ' -dj',xval
        write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -dj ',xval
        write (rendopt,'(a)') ltmp
      endif
      xval=-1.
      call RADPAR('dt',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -dt ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('dc',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -dc ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('dr',xval)
      write (ltmp,'(2a,i2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -dr ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('sj',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -sj ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('st',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -st ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('ab',xval)
      write (ltmp,'(2a,i2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -ab ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('aa',xval)
      write (ltmp,'(2a,f4.2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -aa ',xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('ad',xval)
      write (ltmp,'(2a,i4,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -ad ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('as',xval)
      write (ltmp,'(2a,i4,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -as ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('ar',xval)
      write (ltmp,'(2a,i4,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -ar ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('av',xval)
      write (ltmp,'(2a,3(1x,f4.1),1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -av',xval,xval,xval
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('lr',xval)
      write (ltmp,'(2a,i2,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -lr ',int(xval)
      write (rendopt,'(a)') ltmp
      xval=-1.
      call RADPAR('lw',xval)
      write (ltmp,'(2a,f5.3,1x)') 
     &       rendopt(1:lnblnk(rendopt)),' -lw ',xval
      write (rendopt,'(a)') ltmp

C Run findglare to identify glare sources.
      if (ipckvew.gt.0) then
        write(pf,'(a,a,a,a)') picfil(1:lnblnk(picfil)),'_',
     &                rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.pic'
        write(gf,'(a,a,a,a)') picfil(1:lnblnk(picfil)),'_',
     &                rvewsh(ipckvew)(1:lnblnk(rvewsh(ipckvew))),'.glr'
      else
        write(pf,'(a,a)') picfil(1:lnblnk(picfil)),'_X.pic'
        write(gf,'(a,a)') picfil(1:lnblnk(picfil)),'_X.glr'
      endif
      write(doit,'(12a)') 'cd ',runpath(1:lnblnk(runpath)),
     &            '; findglare -ga 5-',glst(1:lnblnk(glst)),':5 -p ',
     &             pf(1:lnblnk(pf)),' ',rendopt(1:lnblnk(rendopt)),' ',
     &             octfil(1:lnblnk(octfil)),' > ',gf(1:lnblnk(gf))
      write(6,*) doit
      call runit(doit,'-')

      return
      end

C ********************** getdf **********************
C getdf runs daylight factor calculation and then displays them.

      SUBROUTINE getdf
#include "building.h"
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      COMMON/FILEP/IFIL
      common/expath/runpath,pathtype
      common/pophelp/h(60)

      common/rad1/rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      common/raddata/SCENE(MCOM+1),RIFNAME(MCOM+1),SCENERT(MCOM+1),
     &               RIFDESC(MCOM+1),RIFPURP(MCOM+1)
      common/raddata2/NSCENE,ISCENEFOC
      common/raddata3/NBSRIF(MCOM+1),LBSRIF(MCOM+1)
      common/radgrid/LDFGRID

C radgrpts: Daylight factor sensor common
C   NDFP: Number of locations at which to get daylight factor.
C   DFPTS: location to calculate DF at.
C   DFDIR: direction that sensor is looking.
C   DFVALS: Daylight factors.
      common/radgrpts/NDFP,DFPTS(500,3),DFDIR(3),DFVALS(500)
      common/e2rf/rambfil,optnfil
      common/e2rc/crenrp,coconv

      character*72 rofil,rzfil,rskyfil,octfil,picfil,rmfil,glzfil
      character SCENE*28,RIFNAME*72,SCENERT*28,RIFDESC*72,RIFPURP*12
      CHARACTER LDFGRID*72,df*72,outs*124,ltmp*72,doit*256,LBSRIF*72
      character QT*1,rambfil*72,optnfil*72,OUTSTR*124
      character crenrp*160,coconv*40,tfile*72,outsl*160
      character runpath*72,pathtype*24
      character h*72
      integer lnrp  ! length of run path

      logical XST,RECALC

      ITA1 = IFIL+6
      ITA2 = IFIL+7
      QT=CHAR(39)
      lnrp=lnblnk(runpath)

C Check for daylight factor points - if none then try and read grid file.
      if (NDFP.eq.0) then
        call ERPFREE(ITA1,ISTAT)
        write(tfile,'(a,a)')runpath(1:lnrp),
     &                      LDFGRID(1:lnblnk(LDFGRID))
        call FPOPEN(ITA1,ISTAT,1,1,tfile)
        if(ISTAT.eq.0)then
  42      CALL STRIPC(ITA1,OUTSTR,0,ND,0,'grid points',IFER)
          if (IFER.eq.0) then
            NDFP=NDFP+1
            K=0
            CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','grid x',IER)
            DFPTS(NDFP,1)=XTMP
            CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','grid y',IER)
            DFPTS(NDFP,2)=XTMP
            CALL EGETWR(OUTSTR,K,XTMP,0.,0.,'-','grid z',IER)
            DFPTS(NDFP,3)=XTMP
            CALL EGETWR(OUTSTR,K,DFDIR(1),0.,0.,'-','vec x',IER)
            CALL EGETWR(OUTSTR,K,DFDIR(2),0.,0.,'-','vec y',IER)
            CALL EGETWR(OUTSTR,K,DFDIR(3),0.,0.,'-','vec z',IER)
            goto 42
          endif
          CALL DFGRIDLBL('g')
        endif
        call ERPFREE(ITA1,ISTAT)
      endif
      if (NDFP.eq.0) then
        CALL USRMSG('Could not read grid points file.',
     &     'Cannot simulate without this information.  Returning.','W')
        return
      endif

C Ask for convergence limit.
      CONV=0.25
      h(1)='The calculations will strart with one ambient bounce and'
      h(2)='gradually increase the number of bounces until the change'
      h(3)='is less than a value (convergence criteria). The smaller'
      h(4)='the value the longer the calculations will take. '
      h(5)=' '
      h(6)='If the display freezes it may be because the underlying'
      h(7)='rtrace calculations are hung. You may have to kill that'
      h(8)='process. '
      CALL EASKR(CONV,'Daylight factor convergence criteria',
     &     '(Max total diff between iterations) ',0.00,
     &     'F',5.0,'W',0.25,'df convergence criteria',IER,8)

C Reset DFVALS to 0.0
      do 5 I=1,500
        DFVALS(I)=0.0
 5    continue
      ICONV=0

C Check octree up to date.
      call touchrif(RIFNAME(ISCENEFOC))
      
C Check rendering parameters.  If the number of ambient bounces is 
C greater than 1 then the simulation has probably been run before. 
C Ask if the parameters should be reset.
      XAB=-1.
      call RADPAR('ab',XAB)
      if (XAB.gt.1.5) then
        h(1)='Sometimes Radiance gets confused. This is one place'
        h(2)='where starting again can correct this. '
        CALL EASKAB('The rendering parameters would appear to be set',
     &    'from a previous simulation.  Do you want to: ','use them',
     &                     'start from beginning (recommended)',IWR,2)
        if (IWR.eq.2) then
          write (outsl,'(2a)') crenrp(1:lnblnk(crenrp)),
     &                         ' -ab 1 -ad 1024 -as 512 -av 0 0 0'
          write (crenrp,'(a)') outsl
          IFC=3
          call MKRIF(ITA2,RIFNAME(ISCENEFOC),IFC,0,IER)
          call touchrif(RIFNAME(ISCENEFOC))
        endif
      endif

C Daylight factors output file.
      write (df,'(2a)') SCENERT(NSCENE)(1:lnblnk(SCENERT(NSCENE))),'.df'
      call ERPFREE(ITA1,ISTAT)
 1111 write (ltmp,'(2a)') runpath(1:lnrp),df(1:lnblnk(df))
      call FINDFIL(ltmp,XST)
      if(XST)then
        write(outs,'(2a)')'There is an existing file ',df(1:lnblnk(df))
        CALL EASKAB(outs,'Do you want to: ','overwrite',
     &                            'choose another name',IWR,0)
        if (IWR.eq.2) then
          ltmp = df
          h(1)='You have a chance to save the past by giving a'
          h(2)='slightly different file name for the calculatons.'
 1221     CALL EASKS(ltmp,
     &       'Daylight factors results file name (modify slightly) ?',
     &                      ' ',72,'xx.df','df resfile name',IER,2)
          if(ltmp.ne.'  '.and.ltmp.ne.df) then
            df = ltmp
          else
            goto 1221
          endif
          goto 1111
        else
          write(ltmp,'(2a)')runpath(1:lnrp),df(1:lnblnk(df))
          call FPOPEN(ITA1,ISTAT,1,1,ltmp)
          CALL EFDELET(ITA1,ISTAT)
        endif
      endif

C Open sky file and read ground ambient level.
      call RRSKY(ITA1,rskyfil,ga,IER)

C Call rtrace and calculate daylight factors. This is the point where
C the logic jumps back to if additional resolution is required.
 99   write(doit,'(4a,1x,6a,f5.2,4a)') 'cd ',runpath(1:lnrp),
     &        '; rtrace -opv -I -h @',optnfil(1:lnblnk(optnfil)),
     &      octfil(1:lnblnk(octfil)),
     &     ' < ',LDFGRID(1:lnblnk(LDFGRID)),' | rcalc -e ',QT,
     &   '$1=$1;$2=$2;$3=$3;$4=((0.265*$4+0.670*$5+0.065*$6)*100)/(PI*',
     &        ga,')',QT,' > ',df(1:lnblnk(df))
      call runit(doit,'-')

C Now need to read in daylight factors and store in memory.
      DFmaxdiff=0.
      write (ltmp,'(2a)') runpath(1:lnrp),df(1:lnblnk(df))
      call FPOPEN(ITA1,ISTAT,1,1,ltmp)
      do 10 I=1,NDFP
        call STRIPC(ITA1,OUTSTR,4,ND,0,'DF results',IER)
        K=0
        call EGETWR(OUTSTR,K,X,0.0,0.0,'-','X coord',IER)
        call EGETWR(OUTSTR,K,Y,0.0,0.0,'-','Y coord',IER)
        call EGETWR(OUTSTR,K,Z,0.0,0.0,'-','Z coord',IER)
        call EGETWR(OUTSTR,K,DFval,0.0,100.0,'W','DF',IER)
        do 20 J=1,NDFP
          if (abs(DFPTS(J,1)-X).lt.0.001) then
            if (abs(DFPTS(J,2)-Y).lt.0.001) then
              if (abs(DFPTS(J,3)-Z).lt.0.001) then

C Found the DF for the current sensor.
                if (abs(DFVALS(J)-DFval).gt.DFmaxdiff) then
                  DFmaxdiff=abs(DFVALS(J)-DFval)
                endif
                DFVALS(J)=DFval
              endif
            endif
          endif
 20     continue
 10   continue

C Debug...
C      write (6,*) DFmaxdiff

C Display current results and ambient rendering parameters.
      call DFGRIDLBL('d')
      XAB=-1.
      XAD=-1.
      XAS=-1.
      call RADPAR('ab',XAB)
      call RADPAR('ad',XAD)
      call RADPAR('as',XAS)
      write (outs,'(a,i2,2(a,i4))') 'Ambient parameter settings: -ab ',
     &              nint(XAB),' -ad ',nint(XAD),' -as ',nint(XAS)
      call edisp(iuout,outs)

C Check for convergance.
      RECALC=.false.

C Check value of ad.
      if (ICONV.eq.0) then
        YAD=-1.0
        call RADPAR('ad',YAD)
        if (DFmaxdiff.gt.CONV) then

C Increase value and recalculate.
          if (YAD.lt.4000.0) then
            YAD=YAD*2.
            call RADPAR('ad',YAD)
            RECALC=.true.
          else
            DFmaxdiff=9999.9
            ICONV=1
          endif
        else

C Decrease value (last change had no effect) and increase as.
          if (YAD.gt.1025.0) then
            YAD=YAD/2.
            call RADPAR('ad',YAD)
            DFmaxdiff=9999.9
            ICONV=1
          endif
        endif
      endif

C Check value of as.
      if (ICONV.eq.1) then
        YAS=-1.0
        call RADPAR('as',YAS)
        if (DFmaxdiff.gt.CONV) then

C Increase value and recalculate.
          if (YAS.lt.((YAD/2.0)-1.0)) then
            YAS=YAS*2.
            call RADPAR('as',YAS)
            RECALC=.true.
          else
            DFmaxdiff=9999.9
            ICONV=2
          endif
        else

C Decrease value (last change had no effect) and increase ab.
          if (YAS.gt.513.0) then
            YAS=YAS/2.
            call RADPAR('as',YAS)
            DFmaxdiff=9999.9
            ICONV=2
          endif
        endif
      endif

C Check value of ab.
      if (ICONV.eq.2) then
        YAB=-1.0
        call RADPAR('ab',YAB)
        if (DFmaxdiff.gt.CONV) then

C Increase value and recalculate.
          if (YAB.lt.5.0) then
            YAB=YAB+1.0
            call RADPAR('ab',YAB)
            RECALC=.true.
          else
            DFmaxdiff=9999.9
            ICONV=3
          endif
        else

C Decrease value (last change had no effect) and increase ??.
          if (YAB.gt.2.0) then
            YAB=YAB-1.0
            call RADPAR('ab',YAB)
            DFmaxdiff=9999.9
            ICONV=3
          endif
        endif
      endif

C Save RIF file and update options file.
      if (RECALC) then
        call edisp(iuout,'Recalculating with different resolution...')
        IFC=3
        call MKRIF(ITA2,RIFNAME(ISCENEFOC),IFC,0,IER)
        call touchrif(RIFNAME(ISCENEFOC))
        if (NBSRIF(ISCENEFOC).eq.1) then
          call mkrif(ita2,LBSRIF(ISCENEFOC),IFC,1,ier)
          call touchrif(LBSRIF(ISCENEFOC))
        endif

C Move results file and recalculate DFs. Note this move creates
C a catch-22 for viewing the DF later on.
        call ERPFREE(ITA1,ISTAT)
        write(doit,'(7a)') 'cd ',runpath(1:lnrp),'; mv ',
     &        df(1:lnblnk(df)),' ',df(1:lnblnk(df)),'-'
        call runit(doit,'-')
        goto 99
      endif
      call ERPFREE(ITA1,ISTAT)

      return
      end

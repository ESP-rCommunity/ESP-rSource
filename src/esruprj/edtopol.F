C This file is part of the ESP-r system.
C Copyright Energy Systems Research Unit, University of
C Strathclyde, Glasgow Scotland, 2001.

C ESP-r is free software.  You can redistribute it and/or
C modify it under the terms of the GNU General Public
C License as published by the Free Software Foundation 
C (version 2 orlater).

C ESP-r is distributed in the hope that it will be useful
C but WITHOUT ANY WARRANTY; without even the implied
C warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
C PURPOSE. See the GNU General Public License for more
C details.

C You should have received a copy of the GNU General Public
C License along with ESP-r. If not, write to the Free
C Software Foundation, Inc., 59 Temple Place, Suite 330,
C Boston, MA 02111-1307 USA.

C The file edtopol.f is a collection of support facilities for 
C creating and editing the model topology ie. connection lists:
C  EDCONN: Edit/check/clear connection attributes in common block C3
C          and includes logic that use to be found in module cfg.
C  CONFIG: processes the vertex data and presents close matches
C          to confirm before updating cfg and cnn files.
C  ESACON: import surface connection attributes into common
C          block C3 while taking into account confirmation preferences.
C  anchor:   anchor point items (a list of connections & concept).
C  anchlist: manage list of anchors
C  easkconn: Select one or more connections from a list.
C  PROCGDST process GDST command sets (defined in common blocks
C           idsta and anchora.
C  Serchrpl handles search and replace of composition attributes.

C ************* EDCONN 
C Edit/clear/check connection attributes in common blocks via a paging menu.
C ITRU = unit number for user output, IER=0 OK, IER=1 problem.
      SUBROUTINE EDCONN(IER)
#include "building.h"
#include "model.h"

C geometry.h provides commons G0/G1/G2/c20.
#include "geometry.h"
#include "espriou.h"
C espriou.h provides currentfile.
      
      integer lnblnk  ! function definition

      COMMON/FILEP/IFIL
      COMMON/OUTIN/IUOUT,IUIN
      COMMON/SPAD/MMOD,LIMIT,LIMTTY
      
      integer ncomp,ncon
      COMMON/C1/NCOMP,NCON
      COMMON/C3/IC1(MCON),IE1(MCON),ICT(MCON),IC2(MCON),IE2(MCON)
      common/C21/IFCFG,cfgroot,LCFGF
      COMMON/C24/IZSTOCN(MCOM,MS)

      COMMON/gzonpik/izgfoc,nzg,nznog(mcom)

C ITDSP labels toggle: all surf + obs = 0, all surf = 1, partn = 2,
C       similar = 4, surfs + obs+ ground = 5, ground only = 6
C ITBND bounds toggle: static = 0, optimum = 1, zone focus = 2
C ITEPT is
C ITZNM zone name toggle: display = 0, hidden = 1
C ITSNM surface name toggle: display = 0, hidden = 1
C ITORG origin toggle: display = 0, hidden = 1
C ITSNR surf normal toggle: display = 0, hidden = 1.
C ITOBS obstruction toggle: not yet enabled.
C ITHLS highlight toggle: normal 0, constr 1, trans/opaq/cfc 2, part atrib 3
C ITGRD grid toggle: display = 0, hidden = 1
C ITVNO vertex toggle: display = 0, hidden = 1
C ITPPSW current view - perspective/plan/south/west
      COMMON/RAY2/ITDSP,ITBND,ITEPT,ITZNM,ITSNM,ITVNO,ITORG,ITSNR,
     &            ITOBS,ITHLS,ITHLZ,ITGRD,GRDIS,ITPPSW
      COMMON/RAY3/MODIFY,MODLEN,MODBND

C Pause length during sequentail scan longpause (true=1 sec)
      common/scanpause/longpause

      LOGICAL MODIFY,MODLEN,MODBND,OTHEROK
      logical M0SKP,M1SKP,M2SKP,M3SKP,M4SKP,M5SKP,M6SKP,M7SKP,M8SKP
      logical M1OK,M2OK,M4OK,M5OK,M6OK,M7OK
      LOGICAL prob,OK,dok,unixok
      logical longpause

      DIMENSION ITEMS1(23)
      CHARACTER CXSTR*78,outs*124,ITEMS1*34,CFGFN*72
      CHARACTER LCFGF*72
      character cfgroot*24
      character DCNN*72
      character bl*2
      integer MITEM,INO ! max items and current menu item

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='EDCONN'  ! set for subroutine

C Check if Unix-based or DOS based.
      call isunix(unixok)
      longpause=.true.     ! initially use longer pause

C General image option flags for use with cadjview.
      ITDSP=1
      ITBND=1
      ITEPT=0
      ITZNM=0
      ITSNM=0
      ITVNO=1
      ITORG=1
      ITSNR=1
      ITGRD=1
      GRDIS=0.0
      ITRC=0

C On first entry, see if the list is consistent with geometry. If
C prob is .true. then there is at least some inconsistency. The value
C of iprob is the number of inconsistencies. If more than 10
C inconsistencies then something should be done. There are several
C possible vectors for disagreements between what is held in the
C zone geometry files and the connection information held in
C the model connections file:
C a) prj crashed while managing the files resulting in incomplete
C    files (either *.geo or *.cnn)
C b) a 3rd party agent altered the contents of the model files
C    and introduced an error
C c) a glitch in the source code allowed an inconsistency into
C    the model.

C Typically it is assumed that the geometry file is correct and
C the connections file has been corrupted. Thus the `clear` function
C relies on re-scanning the geometry files, updating the values in
C the nzsur() array and then re-setting the common block C3 data.

C Because legacy zone geometry files only held portions of the connetion
C information equivalent to IC1 IE1 and ICT user intervention is needed
C to fully re-establish the C3 common block. The version 1.1 geometry
C file holds sufficient information to re-establish the C3 common
C block with the help of topology checking logic.

C Assume that all surfaces marked as identical, constant, ground and
C adiabatic  and back-to-back require no confirmation (if no
C geometric match is found).
C Assume all existing partitions are re-checked and 
C failed searches brought to users attention.
      M0SKP=.FALSE.
      M1SKP=.TRUE.
      M2SKP=.TRUE.
      M3SKP=.FALSE.
      M4SKP=.TRUE.
      M5SKP=.TRUE.
      M6SKP=.TRUE.
      M7SKP=.TRUE.
      M8SKP=.FALSE.  !  back-to-back in zone assumed to be partitions
      OTHEROK=.TRUE.
      MODIFY=.FALSE.

C CACC is the tolerance between two vertices, IACC is the number
C of corners beyond tolerance which are allowed,
C DACC is the line degree tolerance for setting of corners.
      CACC=0.010
      IACC=0
      DACC=5.0
      DCNN=' '
      bl='  '

C The inital task is to see if there are easily spotted issues with
C the connections list.
      call usrmsg(
     &  'Checking zone surfaces against master list...',' ','-')
      call ckcurmatch(prob,iprob)
      if(prob)then
        call tstamp('>','PRJ: found topology incinsistent')
        if(IPROB.gt.10)then
          write(outs,*) IPROB,' inconsistencies found!'
          call edisp(iuout,outs)
          call usrmsg(
     &    'Topology list dangerously inconsistent. Suggest you',
     &    'clear the current topology!','W')
        else
          call usrmsg(
     &    'Topology list inconsistent. Either clear current topology',
     &    'and/or use the check topology option to resolve this!','W')
        endif
      else
        call usrmsg(
     &    'Checking zone surfaces against master list...done.',' ','-')
      endif

C Refresh the global data arrays used during the checking.
      NZONES=NCOMP
      ISFSUM=0
      CALL ZDATA (0,IER,NZONES,ISFSUM)

C Set for redraw if image on first entry (if refresh set to after
C each edit). Set flag for updating geometry file (for changed
C surface attribute.
    3 INO=-4
      write(ITEMS1(1),'(a,i4,a)')' Connections (',ncon,')'
      ITEMS1(2)=   '  ______________________      '
      ITEMS1(3)=   'b set vertex `close` tolerance'
      ITEMS1(4)=   '  confirm if (already marked):'
      if(M1SKP)then
        ITEMS1(5)= 'c   marked as identical : No  '
      else
        ITEMS1(5)= 'c   marked as identical : Yes '
      endif
      if(M2SKP)then
        ITEMS1(6)= 'd   marked as constant  : No  '
      else
        ITEMS1(6)= 'd   marked as constant  : Yes '
      endif
      if(M3SKP)then
        ITEMS1(7)= 'e   marked as partition : No  '
      else
        ITEMS1(7)= 'e   marked as partition : Yes '
      endif
      if(M4SKP)then
        ITEMS1(8)= 'f   marked as ground    : No  '
      else
        ITEMS1(8)= 'f   marked as ground    : Yes '
      endif
      if(M5SKP)then
        ITEMS1(9)= 'g   marked as adiabatic : No  '
      else
        ITEMS1(9)= 'g   marked as adiabatic : Yes '
      endif
      if(M6SKP)then
        ITEMS1(10)='h   marked as BASESIMP  : No  '
      else
        ITEMS1(10)='h   marked as BASESIMP  : Yes '
      endif
      if(M7SKP)then
        ITEMS1(11)='h   marked as IDENT_CEN : No  '
      else
        ITEMS1(11)='h   marked as IDENT_CEN : Yes '
      endif
      if(M0SKP)then
        ITEMS1(12)='i   if no match found: No     '
      else
        ITEMS1(12)='i   if no match found: Yes    '
      endif
      if(M8SKP)then
        ITEMS1(13)='j   if back-to-back found: No '
      else
        ITEMS1(13)='j   if back-to-back found: Yes'
      endif
      ITEMS1(14)=  '  _______________________     '

      ITEMS1(15)=  'p edit individual connections'

C If contiguity has problems then hilight the selection.
      if(prob)then
        if(IPROB.gt.10)then
          ITEMS1(16)='q CLEAR ALL contiguity  '
        else
          ITEMS1(16)='q CLEAR SOME/ALL contiguity  '
        endif
      else
          ITEMS1(16)='q clear some/all contiguity  '
      endif
      ITEMS1(17)=    'r check via vertex contiguity'
      ITEMS1(18)=  '  _______________________     '

      IF(ITRC.EQ.0)THEN
        ITEMS1(19)='s reporting >> silent         '
      ELSEIF(ITRC.EQ.1)THEN  
        ITEMS1(19)='s reporting >> summary        ' 
      ELSEIF(ITRC.EQ.2)THEN
        ITEMS1(19)='s reporting >> verbose        '
      ENDIF
      ITEMS1(20)=  '! list connections            '
      if(longpause)then
        ITEMS1(21)='* pause during check 1 sec    '
      else
        ITEMS1(21)='* pause during check 0.5 sec  '
      endif
      ITEMS1(22)=  '? help                        '
      ITEMS1(23)=  '- exit                        '
      MITEM=23

C Help text for this menu.
      helptopic='topology_choice_menu'
      call gethelptext(helpinsub,helptopic,nbhelp)

C If user has defined problem and perhaps resized the display then
C redraw the problem image.
      if(MODIFY)then
        MODBND=.TRUE.
        MODLEN=.TRUE.
        NZONES=NCOMP
        nzg=NZONES
        DO 44 I=1,nzg
          nznog(I)=I
  44    CONTINUE

C (Re)Set all surfaces to standard line width.
        izgfoc=0
        if(MMOD.eq.8)then
          CALL INLNST(1)
          CALL ADJVIEW(IER)
        endif
      endif

C Now display the menu (short heading if in text mode).
      if(mmod.eq.8)then
        CALL EMENU('  Surface Connections & Boundary',ITEMS1,MITEM,INO)
      else
        CALL EMENU('Topology',ITEMS1,MITEM,INO)
      endif
      IF(INO.EQ.MITEM)THEN
        RETURN
      ELSEIF(INO.EQ.MITEM-1)THEN

C List help.
        helptopic='topology_choice_menu'
        call gethelptext(helpinsub,helptopic,nbhelp)
        CALL PHELPD('connection section',nbhelp,'-',0,0,IER)
      ELSEIF(INO.EQ.MITEM-2)THEN

C Swop the pause length.
        if(longpause)then
          longpause=.false.
        else
          longpause=.true.
        endif
      ELSEIF(INO.EQ.MITEM-3)THEN

C List connections.
        call tstamp('>','CFG: list topology')
        WRITE(outs,'(A,I3)')' Number of connections = ',NCON
        CALL EDISP(iuout,' ')
        CALL EDISP(iuout,outs)
        CALL CONXINF(1,0,CXSTR)
        CALL EDISP(iuout,CXSTR)
        DO 21 ICON=1,NCON
          CALL CONXINF(1,ICON,CXSTR)
          CALL EDISP(iuout,CXSTR)
   21   CONTINUE
      ELSEIF(INO.EQ.3)THEN

C Set tolerances for vertex comparison.
        call tstamp('>','CFG: enter tolerances')
        CALL EASKR(CACC,' ',' Tolerance (metres) ? ',
     &             0.001,'W',0.2,'W',0.001,'dist tolerance',IER,nbhelp)

        CALL EASKR(DACC,' ',' Corner tolerance (degrees) ?',
     &             0.1,'W',5.0,'W',1.0,'degree tolerance',IER,nbhelp)

        helptopic='surface_corner_detect'
        call gethelptext(helpinsub,helptopic,nbhelp)
        CALL EASKI(IACC,' Number of corners which are allowed outside',
     &    ' of the distance tolerance ? ',
     &     0,'F',2,'W',1,'corner tolerance',IER,nbhelp)

      ELSEIF(INO.EQ.5)THEN

C Flip logic for identical.
        call tstamp('>','CFG: toggle identical')
        if(M1SKP)then
          M1SKP=.false.
        else
          M1SKP=.true.
        endif
      ELSEIF(INO.EQ.6)THEN

C Flip logic for constant.
        call tstamp('>','CFG: toggle constant')
        if(M2SKP)then
          M2SKP=.false.
        else
          M2SKP=.true.
        endif
      ELSEIF(INO.EQ.7)THEN

C Flip logic for partitions.
        call tstamp('>','CFG: toggle partitions')
        if(M3SKP)then
          M3SKP=.false.
        else
          dok=.false.
          call askok('Are you sure you want to skip marked partitions?',
     &               '(see help)',OK,dok,nbhelp)
          if(OK)M3SKP=.true.
        endif
      ELSEIF(INO.EQ.8)THEN

C Flip logic for ground.
        call tstamp('>','CFG: toggle ground')
        if(M4SKP)then
          M4SKP=.false.
        else
          
          M4SKP=.true.
        endif
      ELSEIF(INO.EQ.9)THEN

C Flip logic for adiabatic.
        call tstamp('>','CFG: toggle adiabatic')
        if(M5SKP)then
          M5SKP=.false.
        else
          M5SKP=.true.
        endif
      ELSEIF(INO.EQ.10)THEN

C Flip logic for case of BASESIMP or no match found.
        call tstamp('>','CFG: toggle no match found')
        if(M6SKP)then
          M6SKP=.false.
        else
          M6SKP=.true.
        endif
      ELSEIF(INO.EQ.11)THEN

C Flip logic for case of CEN 13791 partition or no match found.
        call tstamp('>','CFG: toggle no match found')
        if(M7SKP)then
          M7SKP=.false.
        else
          M7SKP=.true.
        endif
      ELSEIF(INO.EQ.12)THEN

C Flip logic for case of UNKNOWN or no match found.
        call tstamp('>','CFG: toggle no match found')
        if(M0SKP)then
          M0SKP=.false.
        else
          M0SKP=.true.
        endif
      ELSEIF(INO.EQ.13)THEN
      
C Flip logic for back-to-back within zone.
        call tstamp('>','CFG: toggle back-to-back')
        if(M8SKP)then
          M8SKP=.false.
        else
          dok=.false.
          helptopic='boundary_back_to_back'
          call gethelptext(helpinsub,helptopic,nbhelp)
          call askok('Do you want to confirm back-to-back surfaces',
     &               'within the room (see help)',OK,dok,nbhelp)
          if(OK)M3SKP=.true.
        endif

      ELSEIF(INO.EQ.15)THEN

C Edit single connection.
        call edaconn(ier)
        MODIFY=.TRUE.
      ELSEIF(INO.EQ.16)THEN

C Clear contiguity.
        helptopic='boundary_clear_all'
        call gethelptext(helpinsub,helptopic,nbhelp)
        CALL EASKABC(' Topology Options:',' ','clear all topology',
     &   'clear subset of topology.','continue',IRT,nbhelp)
        if(IRT.eq.1)then
          dok=.false.
          call askok('About to clear ALL contiguity.','Is this ok',
     &      OK,dok,nbhelp)
          if(.NOT.OK)goto 3

C Clear the connections list by scanning each zone geometry
C file in turn, re-establish nzsur. Once there is a new list
C of connections re-establish the IZSTOCN array.
          call tstamp('>','CFG: clearing contiguity')
          call edisp(iuout,'Clearing contiguity... ')
          ICC=0
          do 87 IZ=1,NCOMP
            call georead(IFIL+1,LGEOM(IZ),IZ,0,itru,IER)
            nzsur(iz)=nsur
            do 88 IS=1,NSUR
              ICC=ICC+1
              IC1(ICC)=IZ
              IE1(ICC)=IS
              ICT(ICC)=0
              IC2(ICC)=0
              IE2(ICC)=0
   88       continue
   87     continue
          NCON=ICC
          do 145 icc = 1, NCON
            IZSTOCN(IC1(icc),IE1(icc))=icc
 145      continue
          write(outs,'(a,i4)')'No. of connections now = ',NCON
          call edisp(iuout,outs)

C Re-establish arrays of zone data now that there are possibly
C different numbers of connections.
          NZONES=NCOMP
          CALL ZDATA (0,IER,NZONES,ISFSUM)

C Check if user wants to re-establish connection data from surface
C attributes.
          dok=.true.
          call askok('Recover surface attribute data?',
     &      '(adiabetic,similar, constant etc. see help)',OK,dok,9)
          if(OK)then
            call tstamp('>','CFG: import surface attributes')
            call ESACON(M1SKP,M2SKP,M4SKP,M5SKP,M6SKP,M7SKP,IER)
            MODIFY=.TRUE.
          endif
        elseif(IRT.eq.2)then
          call tstamp('>','CFG: clearing partial contiguity')
          dok=.false.
          call askok(' ','Clear items marked SIMILAR?',M1OK,
     &      dok,nbhelp)
          call askok(' ','Clear items marked CONSTANT?',M2OK,
     &      dok,nbhelp)
          call askok(' ','Clear items marked GROUND?',M4OK,
     &      dok,nbhelp)
          call askok(' ','Clear items marked ADIABETIC?',M5OK,
     &      dok,nbhelp)
          call askok(' ','Clear items marked BASESIMP?',M6OK,
     &      dok,nbhelp)
          call askok(' ','Clear items marked IDENT_CEN?',M7OK,
     &      dok,nbhelp)
          call usrmsg('Clearing partial contiguity...',bl,'-')
          ICC=0

C << show the surface attributes also be cleared?? >>

          do 187 IZ=1,NCOMP
            call georead(IFIL+1,LGEOM(IZ),IZ,0,itru,IER)
            nzsur(iz)=nsur
            do 188 IS=1,NSUR
              if(ICT(ICC).eq.1.and.M1OK)then
                ICC=ICC+1
                IC1(ICC)=IZ
                IE1(ICC)=IS
                ICT(ICC)=0
                IC2(ICC)=0
                IE2(ICC)=0
              elseif(ICT(ICC).eq.2.and.M2OK)then
                ICC=ICC+1
                IC1(ICC)=IZ
                IE1(ICC)=IS
                ICT(ICC)=0
                IC2(ICC)=0
                IE2(ICC)=0
              elseif(ICT(ICC).eq.4.and.M4OK)then
                ICC=ICC+1
                IC1(ICC)=IZ
                IE1(ICC)=IS
                ICT(ICC)=0
                IC2(ICC)=0
                IE2(ICC)=0
              elseif(ICT(ICC).eq.5.and.M5OK)then
                ICC=ICC+1
                IC1(ICC)=IZ
                IE1(ICC)=IS
                ICT(ICC)=0
                IC2(ICC)=0
                IE2(ICC)=0
              elseif(ICT(ICC).eq.6.and.M6OK)then
                ICC=ICC+1
                IC1(ICC)=IZ
                IE1(ICC)=IS
                ICT(ICC)=0
                IC2(ICC)=0
                IE2(ICC)=0
              elseif(ICT(ICC).eq.7.and.M7OK)then
                ICC=ICC+1
                IC1(ICC)=IZ
                IE1(ICC)=IS
                ICT(ICC)=0
                IC2(ICC)=0
                IE2(ICC)=0
              else
                ICC=ICC+1
                IC1(ICC)=IZ
                IE1(ICC)=IS
                ICT(ICC)=0
                IC2(ICC)=0
                IE2(ICC)=0
              endif
  188       continue
  187     continue
          NCON=ICC
          write(outs,'(a,i4)')'No. of connections now = ',NCON
          call edisp(iuout,outs)

C Re-build zone:surface to connection hash array.
          do 45 icc = 1, NCON
            IZSTOCN(IC1(icc),IE1(icc))=icc
 45       continue

C Check if user wants to re-establish connection data from surface
C attributes.
          call askok('Recover surface attribute data?',
     &      '(adiabetic,similar, constant etc. see help)',
     &      OK,dok,nbhelp)
          if(OK)then
            call tstamp('>','CFG: import surface attributes')
            call ESACON(M1SKP,M2SKP,M4SKP,M5SKP,M6SKP,M7SKP,IER)
            MODIFY=.TRUE.
          endif
        elseif(IRT.eq.3)then
          goto 3
        endif

C Save current common block information to file, jump back and
C update the display.  If icfgv = 3 or 4 then only need to update
C the connections file.  If it changes also update the configuration file.
        if(icfgv.eq.3.or.icfgv.eq.4)then
  286     write(DCNN,'(a,a)')cfgroot(1:lnblnk(cfgroot)),'.cnn'
          if(LCNN(1:1).eq.' ')LCNN=DCNN

          CALL EASKS(LCNN,' Updated surface connections file ?',' ',
     &      72,DCNN,'system connx file name',IER,nbhelp)
          IF(LCNN.EQ.' ')GOTO 286
          CALL EMKCFG('-',IER)
        elseif(icfgv.lt.3)then

C Older configuration file format, ask for its name.
          CFGFN=LCFGF
          CALL EASKS(CFGFN,
     &     'Updated configuration file name ? (best if a new file) ',
     &     ' ',72,'xxx.cfg','revised config file',IER,nbhelp)
          if(CFGFN.ne.' ')LCFGF=CFGFN
          CALL EMKCFG('-',IER)
        endif
      ELSEIF(INO.EQ.17)THEN

C Check vertex matches and rebuild configuration file. If icfgv = 3 or 4 then
C only need to update the connections file. If it changes also update
C the configuration file.
        ITSNM=0
        if(icfgv.eq.3.or.icfgv.eq.4)then
  285     write(DCNN,'(a,a)')cfgroot(1:lnblnk(cfgroot)),'.cnn'
          if(LCNN(1:1).eq.' ')then
            LCNN=DCNN
          endif
          CALL EASKS(LCNN,' Updated surface connections file ?',' ',
     &      72,DCNN,'system connx file name',IER,nbhelp)
          IF(LCNN.EQ.' ')GOTO 285
        elseif(icfgv.lt.3)then

C Older configuration file format, ask for its name.
          CFGFN=LCFGF
          CALL EASKS(CFGFN,
     &     'Updated configuration file name ? (best if a new file) ',
     &     ' ',72,'xxx.cfg','revised config file',IER,nbhelp)
          if(CFGFN.ne.' ')LCFGF=CFGFN
        endif

C Look for connections.
        call tstamp('>','CFG: do graphic match of surfaces')
        CALL CONFIG(NZONES,CACC,IACC,DACC,M0SKP,M1SKP,M2SKP,M3SKP,
     &    M4SKP,M5SKP,M6SKP,M7SKP,M8SKP,OTHEROK)

C Re-build zone:surface to connection hash array.
        do 43 icc = 1, NCON
          IZSTOCN(IC1(icc),IE1(icc))=icc
 43     continue

C Save data to configuration and connections file.
        CALL EMKCFG('-',IER)
        MODIFY=.TRUE.
      ELSEIF(INO.EQ.19)THEN

C Toggle trace level.
        ITRC=ITRC+1
        IF(ITRC.GT.2)ITRC=0
        INO=-4
      ELSE
        INO=-1
        GOTO 3
      ENDIF
      GOTO 3

      END 

C ************** CONFIG
C CONFIG processes the vertex data and presents close matches for
C the user to confirm before writing to temporary configuration file.
      SUBROUTINE CONFIG(NZONES,CACC,IACC,DACC,M0SKP,M1SKP,M2SKP,M3SKP,
     &  M4SKP,M5SKP,M6SKP,M7SKP,M8SKP,OTHEROK)
#include "building.h"
#include "model.h"
#include "site.h"
#include "geometry.h"
#include "prj3dv.h"
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      COMMON/SPAD/MMOD,LIMIT,LIMTTY
      COMMON/FILEP/IFIL
      COMMON/gzonpik/izgfoc,nzg,nznog(mcom)
      COMMON/RAY2/ITDSP,ITBND,ITEPT,ITZNM,ITSNM,ITVNO,ITORG,ITSNR,
     &            ITOBS,ITHLS,ITHLZ,ITGRD,GRDIS,ITPPSW
      COMMON/RAY3/MODIFY,MODLEN,MODBND
      COMMON/RAY5/ZCOG(MCOM,3),XMN,YMN,ZMN,XMX,YMX,ZMX
      COMMON/RAY6/LINSTY(MCON)

      COMMON/C3/IC1(MCON),IE1(MCON),ICT(MCON),IC2(MCON),IE2(MCON)
      common/C21/IFCFG,cfgroot,LCFGF
      COMMON/C24/IZSTOCN(MCOM,MS)

C G5 required for updating zone geometry file (until such time as geometry
C write can use G6 common blocks).

C Pause length during sequentail scan longpause (true=1 sec)
      common/scanpause/longpause

      DIMENSION COORD1(MV,3), COORD2(MV,3)
      dimension ICVALS(MCOM),TOTHER(MS,3),ipmz(3),ipms(3)

      LOGICAL MODIFY,MODLEN,MODBND,OK,DOK,DOIT,OTHEROK,UPDGEO
      logical M0SKP,M1SKP,M2SKP,M3SKP,M4SKP,M5SKP,M6SKP,M7SKP,M8SKP
      logical closea,closee,close,longpause
      logical newgeo  ! to use for testing if new/old geometry file.
      character outs*124,CXSTR*78,SN*12
      character SO*24,TOTHER*24
      character DESCRC*25
      character DCNN*72,cfgroot*24,LCFGF*72,bl*2
      integer izselfcheck  ! the surface being tested
      logical selfcheck  ! set true if currently looking within zone

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='CONFIG'  ! set for subroutine

C CACC is the tolerance allowed between two vertices.
C TOTHER is array of temporary new topology attributes for current zone.

C ICNT holds the number of matching vertices between two surfaces.
      bl='  '
      ITSNM=0
      ICNT=0
      IC=0
      newgeo=.false.  ! assume older format geometry.

C Set for redraw if image on first entry (if refresh set to after
C each edit).
      MODIFY=.TRUE.
      MODLEN=.TRUE.
      MODBND=.TRUE.

C Request which zones to include.
      helptopic='setting_up_topol'
      call gethelptext(helpinsub,helptopic,nbhelp)
      ICPIC=NZONES
      CALL EPICKS(ICPIC,ICVALS,' ',' Which zones to include: ',
     &  12,NZONES,zname,' zone list',IER,nbhelp)

C Loop for each zone, only doing comparison for selected zones.
      DO 100 I=1,NZONES
        IZ=I
        DOIT=.FALSE.
        UPDGEO=.FALSE.
        do 215 ix=1,icpic
          if(IZ.eq.ICVALS(ix))DOIT=.TRUE.
  215   continue
        if(DOIT)then

C Get confirmation for continuing, if user wishes to skip a
C selected zone then updae the IC count to reflect the surfaces
C skiped.
          if(IZ.ne.1)then
            write(outs,'(3a)')' Continue with ',zname(IZ),' ?'
            dok=.true.
            CALL ASKOK(outs,'(see help)',OK,dok,nbhelp)
            if(.NOT.OK)then
              IC=IC+nzsur(IZ)
              goto 100
            endif
          endif
          WRITE(outs,'(A,I2,A,A)') 'Processing (',IZ,') ',zname(IZ)
          call edisp(iuout,outs)
          call edisp(iuout,' corners|connx| description ')
          call edisp(iuout,' in surf|index| of existing topology')
        endif

C Display the reference zone (if type 3 then display both).
C Remember topology attributes for reference zone.
        IUO=IFIL+1
        call georead(IUO,LGEOM(IZ),IZ,0,iuout,IER)
        do 322 IJ=1,NSUR
          ICN=IZSTOCN(iz,ij)
          TOTHER(IJ,1)=SSOTHER(ICN,1)
          TOTHER(IJ,2)=SSOTHER(ICN,2)
          TOTHER(IJ,3)=SSOTHER(ICN,3)
  322   continue
        MODIFY=.TRUE.
        MODBND=.TRUE.

C Loop over each surface and increment the counter IC.
        DO 110 J=1,nzsur(IZ)
          JS=J
          IC=IC+1
          izselfcheck=JS  ! remember the surface being tested

C If zone is not to be included in the analysis, jump.
          if(.NOT.DOIT)goto 110

C Reset all surface lines to standard width and then the specific 
C surface(s) under consideration to wide lines. If other side
C is not a type 3 then don`t highlight.
          if(MMOD.eq.8)then
            CALL INLNST(1)
            LINSTY(IC)=2
          endif
          nzg=1
          nznog(1)=IZ
          izgfoc = IZ
          if(MMOD.eq.8)CALL CADJVIEW(IER)
          MODIFY=.TRUE.

C Find number of corners and their coordinates for this surface.
          CALL SFCRNR(DACC,IZ, JS, NAPIC1, COORD1)
          CALL CONXINF(1,IC,CXSTR)
          write(outs,'(I6,3X,A)') NAPIC1,CXSTR
          call edisp(iuout,outs)

C If user said skip confirmation of marked partitions, check and update the
C surface attribute if a dash and jump around.
          if(M3SKP.and.(ICT(IC).eq.3))then
            call edisp(iuout,'known connection skipped.')
            if(MMOD.eq.8)then
              if(longpause)then
                call pauses(1)
              else
                call pausems(400)
              endif
            endif

C If tother(JS,2) is a dash then update with IC2 IE2.
            if(TOTHER(JS,2)(1:1).eq.'-')then
              write(TOTHER(JS,1),'(a)') 'ANOTHER'
              write(tother(JS,2),'(i2.2)') IC2(ic)
              write(tother(JS,3),'(i2.2)') IE2(ic)
              UPDGEO=.TRUE.
            endif
            goto 110
          endif

C Reset number of geometric matches. If more than one then ask.
          ipmatch=0

C Loop over zones including this zone so that back-to-back surfaces
C are also detected.
          DO 200 II=1, NZONES
            if (II.EQ.IZ)then
	      selfcheck=.true.  ! currently looking within zone
            else
              selfcheck=.false.
            endif

C Find if there is a surface connection. Skip past self if in same zone.
            DO 210 JJ=1,nzsur(II)
              if(selfcheck.and.JJ.eq.izselfcheck)then
	        goto 210
              endif
	      
C Find number of corners and their coordinates for the other surface.
              CALL SFCRNR(DACC,II, JJ, NAPIC2, COORD2)

C If the number of corners of the two surface are equal then
C check if their coordinates are within tolerance.
              ICNT=0
              IF (NAPIC1.EQ.NAPIC2) THEN
                DO 300 K=1, NAPIC1
                  DO 350 KK=1, NAPIC1
                    XDIFF=ABS(COORD2(KK,1)-COORD1(K,1))
                    YDIFF=ABS(COORD2(KK,2)-COORD1(K,2))
                    ZDIFF=ABS(COORD2(KK,3)-COORD1(K,3))
                    IF(XDIFF.LE.CACC.AND.YDIFF.LE.CACC.AND.
     &                 ZDIFF.LE.CACC) THEN
                      ICNT=ICNT+1
                      GOTO 300
                    ENDIF
  350             CONTINUE
  300           CONTINUE
              ENDIF

C If the number of matching corners is within the IACC limit, then
C present choice to the user.
              IF ((NAPIC1-ICNT).le.IACC) THEN
                ipmatch=ipmatch+1
                if(ipmatch.le.3)then
                  ipmz(ipmatch)=II
                  ipms(ipmatch)=JJ
                endif
              ENDIF

C Reset ICNT before commencing a new loop.
              ICNT=0
  210       CONTINUE
  200     CONTINUE

C Depending on how many matches were found, proceed.  If there were
C no matches then check for existing IDENTICAL or CONSTANT or GROUND
C or ADIABATIC or BASESIMP or IDENT_CEN and set these if the user
C asked to skip onfirmation.
          if(ipmatch.eq.0)then

C If user said skip confirmation of marked IDENTICAL, check and update the
C surface attribute if it does not match and jump around.
            WRITE(SO,'(A)') TOTHER(JS,1)
            if(M1SKP.and.(ICT(IC).eq.1))then
              call edisp(iuout,'known connection skipped.')
              if(MMOD.eq.8)then
                if(longpause)then
                  call pauses(1)
                else
                  call pausems(400)
                endif
              endif
              if(SO(1:7).ne.'SIMILAR')then
                TOTHER(JS,1)='SIMILAR'
                write(tother(JS,2),'(i2.2)') IC2(ic)
                write(tother(JS,3),'(i2.2)') IE2(ic)
                UPDGEO=.TRUE.
              endif
              goto 110
            endif

C If user said skip confirmation of marked CONSTANT, check and update the
C surface attribute if it does not match and jump around.
            if(M2SKP.and.(ICT(IC).eq.2))then
              call edisp(iuout,'known connection skipped.')
              if(MMOD.eq.8)then
                if(longpause)then
                  call pauses(1)
                else
                  call pausems(400)
                endif
              endif
              if(SO(1:8).ne.'CONSTANT')then
                TOTHER(JS,1)='CONSTANT'
                write(tother(JS,2),'(i2.2)') IC2(ic)
                write(tother(JS,3),'(i2.2)') IE2(ic)
                UPDGEO=.TRUE.
              endif
              goto 110
            endif

C If user said skip confirmation of marked GROUND, check and update the
C surface attribute if it does not match and jump around.
            if(M4SKP.and.(ICT(IC).eq.4))then
              call edisp(iuout,'known connection skipped.')
              if(MMOD.eq.8)then
                if(longpause)then
                  call pauses(1)
                else
                  call pausems(400)
                endif
              endif
              if(SO(1:6).ne.'GROUND')then
                TOTHER(JS,1)='GROUND'
                write(tother(JS,2),'(i2.2)') IC2(ic)
                write(tother(JS,3),'(i2.2)') IE2(ic)
                UPDGEO=.TRUE.
              endif
              goto 110
            endif

C If user said skip confirmation of marked ADIABATIC, check and update the
C surface attribute if it does not match and jump around.
            if(M5SKP.and.(ICT(IC).eq.5))then
              call edisp(iuout,'known connection skipped.')
              if(MMOD.eq.8)then
                if(longpause)then
                  call pauses(1)
                else
                  call pausems(400)
                endif
              endif
              if(SO(1:9).ne.'ADIABATIC')then
                TOTHER(JS,1)='ADIABATIC'
                write(tother(JS,2),'(i2.2)') IC2(ic)
                write(tother(JS,3),'(i2.2)') IE2(ic)
                UPDGEO=.TRUE.
              endif
              goto 110
            endif

C If user said skip confirmation of marked BASESIMP, check and update the
C surface attribute if it does not match and jump around. 
            if(M6SKP.and.(ICT(IC).eq.6))then
              call edisp(iuout,'known connection skipped.')
              if(MMOD.eq.8)then
                if(longpause)then
                  call pauses(1)
                else
                  call pausems(400)
                endif
              endif
              if(SO(1:8).ne.'BASESIMP')then
                TOTHER(JS,1)='BASESIMP'
                write(tother(JS,2),'(i2.2)') IC2(ic)
                write(tother(JS,3),'(i2.2)') IE2(ic)
                UPDGEO=.TRUE.
              endif
              goto 110
            endif

C If user said skip confirmation of marked IDENT_CEN, check and update the
C surface attribute if it does not match and jump around. 
            if(M7SKP.and.(ICT(IC).eq.7))then
              call edisp(iuout,'known connection skipped.')
              if(MMOD.eq.8)then
                if(longpause)then
                  call pauses(1)
                else
                  call pausems(400)
                endif
              endif
              if(SO(1:9).ne.'IDENT_CEN')then
                TOTHER(JS,1)='IDENT_CEN'
                write(tother(JS,2),'(i2.2)') IC2(ic)
                write(tother(JS,3),'(i2.2)') IE2(ic)
                UPDGEO=.TRUE.
              endif
              goto 110
            endif

C Ask user if some other type of connection. If M0SKP is true then
C set connection to exterior and proceed.
            if(OTHEROK)then
              if(M0SKP)then
                IC1(IC)=IZ
                IE1(IC)=JS
                ICT(IC)=0
                IE2(IC)=0
                IC2(IC)=0
                if(SO(1:8).ne.'EXTERIOR')then
                  TOTHER(JS,1)='EXTERIOR'
                  write(tother(JS,2),'(i2.2)') IC2(ic)
                  write(tother(JS,3),'(i2.2)') IE2(ic)
                  UPDGEO=.TRUE.
                endif
                call edisp(iuout,'no match found setting to EXTERIOR.')
                if(MMOD.eq.8)then
                  if(longpause)then
                    call pauses(1)
                  else
                    call pausems(400)
                  endif
                endif
              else

C Setup contextural help for boundary conditions.
                helptopic='boundary_choices'
                call gethelptext(helpinsub,helptopic,nbhelp)
                if(ICT(IC).eq.3)then
                  write(outs,'(a,a)') 
     &              'Partition, but no geometric match found. Is ',
     &              CXSTR(1:lnblnk(CXSTR))
                elseif(ICT(IC).ne.3)then
                  write(outs,'(a,a)')'No geometric match found. Is ',
     &              CXSTR(1:lnblnk(CXSTR))
                  idno=ICT(IC)
                endif
                iart=0
                call MENUATOL(outs,' Connection options ',
     &  'a exterior                  ','b dynamic (similar) boundary',
     &  'c static boundary conditions','d ground (standard profile) ',
     &  'e ground (user def profile) ','f ground (3D conduction)    ',
     &  'g adiabatic (no heat flux)  ','h BASESIMP foundation       ',
     &  'i CEN 13791 partition       ',
     &  'j UNKNOWN (at this time)    ','k accept current            ',
     &   ' ',iart,idno,nbhelp)
                if(IART.eq.0)then
                  continue
                elseif(IART.eq.1)then
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=0
                  IE2(IC)=0
                  IC2(IC)=0
                  if(SO(1:8).ne.'EXTERIOR')then
                    TOTHER(JS,1)='EXTERIOR'
                    write(tother(JS,2),'(i2.2)') IC2(ic)
                    write(tother(JS,3),'(i2.2)') IE2(ic)
                    UPDGEO=.TRUE.
                  endif
                elseif(IART.eq.2)then
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=1
                  IE2(IC)=0
                  IC2(IC)=0
                  if(SO(1:7).ne.'SIMILAR')then
                    TOTHER(JS,1)='SIMILAR'
                    write(tother(JS,2),'(i2.2)') IC2(ic)
                    write(tother(JS,3),'(i2.2)') IE2(ic)
                    UPDGEO=.TRUE.
                  endif
                elseif(IART.eq.3)then
                  CALL EASKR(VAL,' ',' Constant temperature ? ',
     &              -99.,'F',99.,'F',20.,'adjacent temperature',
     &              IER,nbhelp)
                  CALL EASKR(VAL2,' ',' Constant rad (W/m^2) ? ',
     &              -999.,'F',999.,'F',0.,'adjacent rad',IER,nbhelp)
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=2
                  IE2(IC)=INT(VAL2)
                  IC2(IC)=INT(VAL)
                  if(SO(1:8).ne.'CONSTANT')then
                    TOTHER(JS,1)='CONSTANT'
                    write(tother(JS,2),'(i2.2)') IC2(ic)
                    write(tother(JS,3),'(i2.2)') IE2(ic)
                    UPDGEO=.TRUE.
                  endif
                elseif(IART.eq.4)then

C List out standard profiles, assuming that if June is 0.0, then the
C profile has not been defined.
                  CALL EDISP(iuout,'Standard ground profiles Jan-Dec:')
                  CALL EDISP(iuout,
     &              'id  Jan, Feb, Mar, Apr, May, Jun, Jul...')
                  do 21 igrdp=1,mgrdp
                    CALL ECLOSE(GRDTMP(6,igrdp),0.0,0.001,close)
                    if(.NOT.close)then
                      WRITE(OUTS,'(I2,2a)')igrdp,' ',grdtmpname(IGRDP)
                      call edisp(iuout,outs)
                      WRITE(OUTS,'(I2,12F5.1)')igrdp,
     &                  (GRDTMP(JG,IGRDP),JG=1,12)
                      call edisp(iuout,outs)
                    endif
21                continue
                  helptopic='boundary_ground'
                  call gethelptext(helpinsub,helptopic,nbhelp)
                  iic2=ic2(IC)
  777             CALL EASKI(IIC2,' Monthly (standard) profile index?',
     &              ' ',1,'F',mgrdp,'F',1,'ground profile',IER,nbhelp)
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=4
                  IF(IIC2.GT.0)THEN
                    IC2(IC)=iic2
                    IE2(IC)=0
                    if(SO(1:6).ne.'GROUND')then
                      TOTHER(JS,1)='GROUND'
                      write(tother(JS,2),'(i2.2)') IC2(ic)
                      write(tother(JS,3),'(i2.2)') IE2(ic)
                      UPDGEO=.TRUE.
                    endif
                  ELSE
                    CALL USRMSG(' ',' Unacceptable ground profile...',
     &  'W')
                    GOTO 777
                  ENDIF
                elseif(IART.eq.5)then

C List out user defined profiles, assuming that if June is 0.0, then the
C profile has not been defined.
                  if(NGRDP.gt.0)then
                    CALL EDISP(iuout,' ')
                    do 22 igrdp=1,NGRDP    
                      CALL EDISP(iuout,
     &                  'User defined ground profile Jan-Dec:')
                      WRITE(OUTS,'(12F6.1)')(UGRDTP(JG,IGRDP),JG=1,12)
                      call edisp(iuout,outs)
 22                 continue
                    CALL EASKI(IIE2,
     &                'User defined ground profile index?',
     &                ' ',0,'F',9,'F',1,'user defined profile',
     &                IER,nbhelp)
                    IC1(IC)=IZ
                    IE1(IC)=JS
                    ICT(IC)=4
                    IC2(IC)=0
                    IE2(IC)=iie2
                    if(SO(1:6).ne.'GROUND')then
                      TOTHER(JS,1)='GROUND'
                      write(tother(JS,2),'(i2.2)') IC2(ic)
                      write(tother(JS,3),'(i2.2)') IE2(ic)
                      UPDGEO=.TRUE.
                    endif
                  else
                    call usrmsg(
     &               'No user defined ground profiles have been found.',
     &               'Go to `problem context` to define these.','W')
                  endif
                elseif(iart.eq.6)then 

C Link to a 3D conduction model..
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=4
                  IC2(IC)=-3
                  IE2(IC)=0
                  if(SO(1:6).ne.'GROUND')then
                    TOTHER(IE1(JS),1)='GROUND'
                    write(tother(JS,2),'(i2.2)') IC2(ic)
                    write(tother(JS,3),'(i2.2)') IE2(ic)
                    UPDGEO=.TRUE.
                  endif
                elseif(IART.eq.7)then
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=5
                  IE2(IC)=0
                  IC2(IC)=0
                  if(SO(1:9).ne.'ADIABATIC')then
                    TOTHER(JS,1)='ADIABATIC'
                    write(tother(JS,2),'(i2.2)') IC2(ic)
                    write(tother(JS,3),'(i2.2)') IE2(ic)
                    UPDGEO=.TRUE.
                  endif
                elseif(iart.eq.8)then 

C BASESIMP start.
C Get BASESIMP configuration via call to bsimtype. Save state of current
C menu and recover after the call.
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=6
                  IBS=IC2(IC)
                  call bsimtype(ibs)
                  IC2(IC)=IBS

C Get `surface weighting factor', the percentage of the BASESIMP heat loss to
C attribute to the surface under consideration.
                  Ifrac=IE2(IC)
                  helptopic='boundary_basesimp'
                  call gethelptext(helpinsub,helptopic,nbhelp)
                  CALL EASKI(Ifrac,
     &              ' Percent of BASESIMP loss to this surface?'
     &             ,' ',0,'F',100,'F',100,'BASESIMP heat loss percent',
     &              IER,nbhelp)
                  IE2(IC)=Ifrac
                  if(SO(1:8).ne.'BASESIMP')then
                    TOTHER(IE1(JS),1)='BASESIMP'
                    write(tother(JS,2),'(i2.2)') IC2(ic)
                    write(tother(JS,3),'(i2.2)') IE2(ic)
                    UPDGEO=.TRUE.
                  endif
C BASESIMP end.
                elseif(IART.eq.9)then
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=7
                  IE2(IC)=0
                  IC2(IC)=0
                  if(SO(1:7).ne.'IDENT_CEN')then
                    TOTHER(JS,1)='IDENT_CEN'
                    write(tother(JS,2),'(i2.2)') IC2(ic)
                    write(tother(JS,3),'(i2.2)') IE2(ic)
                    UPDGEO=.TRUE.
                  endif

C CEN 13791 partition end.
                elseif(IART.eq.10)then
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=-1
                  IE2(IC)=0
                  IC2(IC)=0
                  if(SO(1:7).ne.'UNKNOWN')then
                    TOTHER(JS,1)='UNKNOWN'
                    write(tother(JS,2),'(i2.2)') IC2(ic)
                    write(tother(JS,3),'(i2.2)') IE2(ic)
                    UPDGEO=.TRUE.
                  endif
                endif
              endif
            endif
          elseif(ipmatch.eq.1)then

C Only one possible matching surface, inform user and then proceed. If
C selfcheck is false then the match is as a partition to a surface in
C another zone. If selfcheck is true then we have a back-to-back
C match and we need to test the value of M8SKP.
            II=ipmz(1)
            JJ=ipms(1)

C Re-evaluate the state of selfcheck based on the surface that was
C found to match.
            if (II.EQ.IZ)then
	      selfcheck=.true.  ! currently looking within zone
            else
              selfcheck=.false.
            endif

            MODBND=.TRUE.
            if(MMOD.eq.8)then
              CALL INLNST(1)
              LINSTY(IC)=2
            endif
            nzg=2
            nznog(1)=IZ
            nznog(2)=II
            CALL SURADJ(II,JJ,IE,TMP,IZC,ISC,ICO,DESCRC)
            if(MMOD.eq.8)LINSTY(ICO)=2
            izgfoc = IZ
            if(MMOD.eq.8)CALL CADJVIEW(IER)
            MODIFY=.TRUE.
            MODBND=.TRUE.
            IC1(IC)=IZ
            IE1(IC)=JS
            ICT(IC)=3
            IC2(IC)=II
            IE2(IC)=JJ
            call usrmsg(' ',bl,'-')
            if(MMOD.eq.8)then
              if(longpause)then
                call pauses(1)
              else
                call pausems(400)
              endif
            endif

C If an actual partition then no need for confirmation, just
C update the attributes.
            if(.NOT.selfcheck)then
              write(TOTHER(JS,1),'(a)') 'ANOTHER'
              write(tother(JS,2),'(i2.2)') IC2(ic)
              write(tother(JS,3),'(i2.2)') IE2(ic)
              UPDGEO=.TRUE.
              ICN=IZSTOCN(II,JJ)
              SN=SSNAME(icn)
              WRITE(outs,'(4a)')' accepting match to surface ',
     &          SN(1:lnblnk(SN)),' in ',zname(II)(1:lnzname(II))
              call edisp(iuout,outs)
              goto 110  ! no need to check further
            else
	    
C If we are in the same room then we have a back-to-back surface.
C If M8SKP was set to false then go ahead and
C make it a partition without bothering to ask the user.
              if(M8SKP)then
                write(TOTHER(JS,1),'(a)') 'ANOTHER'
                write(tother(JS,2),'(i2.2)') IC2(ic)
                write(tother(JS,3),'(i2.2)') IE2(ic)
                UPDGEO=.TRUE.
                ICN=IZSTOCN(II,JJ)
                SN=SSNAME(icn)
                WRITE(outs,'(3a)')' accepting match to surface ',
     &            SN(1:lnblnk(SN)),' in current zone.'
                call edisp(iuout,outs)
                goto 110  ! no need to check further
              else
                CALL EASKABC('Matched surface within room:',' ',
     &            'set to back-to-back','set to ADIABETIC',
     &            'set to UNKNOWN',IRTA,nbhelp)
                if(IRTA.eq.1)then
                  write(TOTHER(JS,1),'(a)') 'ANOTHER'
                  write(tother(JS,2),'(i2.2)') IC2(ic)
                  write(tother(JS,3),'(i2.2)') IE2(ic)
                  UPDGEO=.TRUE.
                  ICN=IZSTOCN(II,JJ)
                  SN=SSNAME(icn)
                  WRITE(outs,'(3a)')' accepting match to surface ',
     &              SN(1:lnblnk(SN)),' in current zone.'
                  call edisp(iuout,outs)
                elseif(IRTA.eq.2)then
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=5
                  IE2(IC)=0
                  IC2(IC)=0
                  TOTHER(JS,1)='ADIABATIC'
                  write(tother(JS,2),'(i2.2)') IC2(ic)
                  write(tother(JS,3),'(i2.2)') IE2(ic)
                  UPDGEO=.TRUE.
                elseif(IRTA.eq.3)then
                  IC1(IC)=IZ
                  IE1(IC)=JS
                  ICT(IC)=-1
                  IE2(IC)=0
                  IC2(IC)=0
                  TOTHER(JS,1)='UNKNOWN'
                  write(tother(JS,2),'(i2.2)') IC2(ic)
                  write(tother(JS,3),'(i2.2)') IE2(ic)
                  UPDGEO=.TRUE.
                endif
                goto 110  ! no need to check further
              endif
            endif
          elseif(ipmatch.gt.1)then

C If there is more than ONE possible matching geometric connection
C then confirm with the user. First check if one of the matches
C is of a reasonable orientation.
            iipmatch=MIN0(ipmatch,3)
            write(outs,'(a,i2,a,a)') 'There are ',iipmatch,
     &        ' possible matches with ',CXSTR(1:lnblnk(CXSTR))
            call edisp(iuout,outs)
            do 841 ipml=1,iipmatch
              IIx=ipmz(ipml)
              JJx=ipms(ipml)
              CALL SURADJ(IIx,JJx,IE,TMP,IZC,ISC,ICO,DESCRC)
              SELV=SSPELV(ic)+SSPELV(ico)
              DAZI=SSPAZI(ic)-SSPAZI(ico)
              DAZI=ABS(DAZI)
              call eclose(DAZI,180.0,3.0,closea)
              call eclose(SELV,0.0,3.0,closee)
              ICN=IZSTOCN(IIx,JJx)
              SN=SSNAME(ICN)
              if(closea.and.closee)then
                WRITE(outs,'(4a)')
     &            ' Probable (orientation close) match to surface ',
     &            SN(1:lnblnk(SN)),' in ',zname(IIx)(1:lnzname(IIx))
              else
                WRITE(outs,'(4a)')
     &            ' Possible (orientation not close) match to surface ',
     &            SN(1:lnblnk(SN)),' in ',zname(IIx)(1:lnzname(IIx))
              endif
              call edisp(iuout,outs)
 841        continue
 840        continue

C With two surfaces close together it is difficult to see the connection.
C Zoom in on the surface in question - find its bounding box and centre
C the view on it and calculate the angle of view to that box.
            if(MMOD.eq.8)then
              call surbox(iz,js,1.,cx,cy,cz,sxmx,sxmn,symx,symn,szmx,
     &          szmn)
              call saveview
              call ang3vtx(sxmn,symn,sznb,EYEM(1),EYEM(2),EYEM(3),sxmx,
     &          symx,szmx,angn)
              ANG=angn
              HANG=ANG/2.0
            endif
            do 843 ipml=1,iipmatch
              ITBND=0
              VIEWM(1)=cx
              VIEWM(2)=cy
              VIEWM(3)=cz
              XMN=sxmn
              YMN=symn
              ZMN=szmn
              XMX=sxmx
              YMX=symx
              ZMX=szmx
              MODIFY=.TRUE.
              MODLEN=.TRUE.
              if(MMOD.eq.8)CALL INLNST(1)
              if(MMOD.eq.8)LINSTY(IC)=2
              nzg=2
              II=ipmz(ipml)
              JJ=ipms(ipml)
              nznog(1)=IZ
              nznog(2)=II
              if(MMOD.eq.8)LINSTY(ICO)=2
              izgfoc = IZ
              if(MMOD.eq.8)CALL CADJVIEW(IER)
              ICN=IZSTOCN(II,JJ)
              SN=SSNAME(ICN)
              WRITE(outs,'(4a)')' Probable match to surface ',
     &            SN(1:lnblnk(SN)),' in ',zname(II)(1:lnzname(II))
              dok=.true.
              helptopic='multi_match_partn'
              call gethelptext(helpinsub,helptopic,nbhelp)
              CALL ASKOK(outs,' Accept this? (see help)',
     &          OK,dok,nbhelp)
              IF(OK)then
                IC1(IC)=IZ
                IE1(IC)=JS
                ICT(IC)=3
                IC2(IC)=II
                IE2(IC)=JJ

C Update surface attributes and then restore the view points.
                write(TOTHER(JS,1),'(a)') 'ANOTHER'
                write(tother(JS,2),'(i2.2)') IC2(ic)
                write(tother(JS,3),'(i2.2)') IE2(ic)
                UPDGEO=.TRUE.
                if(MMOD.eq.8)call recoview
                ITBND=1
                MODLEN=.TRUE.
                MODIFY=.TRUE.
                MODBND=.TRUE.

C Move to the next surface.
                ICNT=0
                goto 110
              endif
 843        continue

C If reached this point then no surface selected. 
            if(MMOD.eq.8)call recoview
            ITBND=1
            MODBND=.TRUE.
            MODIFY=.TRUE.
            MODLEN=.TRUE.
            CALL EASKABCD(' None of the suggestions taken:',' ',
     &        'loop again','set to UNKNOWN','set to EXTERIOR',
     &        'continue',IRTA,nbhelp)
            if(irta.eq.1)then
              goto 840
            elseif(irta.eq.2)then
              IC1(IC)=IZ
              IE1(IC)=JS
              ICT(IC)=-1   ! unknown connection is a -1
              IE2(IC)=0
              IC2(IC)=0
              if(SO(1:7).ne.'UNKNOWN')then
                TOTHER(JS,1)='UNKNOWN'
                write(tother(JS,2),'(i2.2)') IC2(ic)
                write(tother(JS,3),'(i2.2)') IE2(ic)
                UPDGEO=.TRUE.
              endif
            elseif(irta.eq.3)then
              IC1(IC)=IZ
              IE1(IC)=JS
              ICT(IC)=0
              IE2(IC)=0
              IC2(IC)=0
              if(SO(1:7).ne.'EXTERIOR')then
                TOTHER(JS,1)='EXTERIOR'
                write(tother(JS,2),'(i2.2)') IC2(ic)
                write(tother(JS,3),'(i2.2)') IE2(ic)
                UPDGEO=.TRUE.
              endif
            elseif(irta.eq.4)then
              ICNT=0
              goto 110
            endif

C Reset line style.
            if(MMOD.eq.8)CALL INLNST(1)
          ENDIF
  110   CONTINUE

C Update geometry file if required.  Do this by re-reading the
C geometry file, then update SOTHER and SSOTHER and write out the
C geometry file with the updated boundary tag. The ssother will be
C held in memory until the connections file is written.

C << what about using CALL ESCZONE(ICOMP) and then CALL ERCZONE(ICOMP)? >>

        if(UPDGEO)then
          call edisp(iuout,' Updating surface attributes...')
          call georead(IFIL+2,LGEOM(IZ),IZ,0,iuout,IER)
          do 323 IJ=1,NSUR
            SOTHER(IJ,1)=TOTHER(IJ,1)
            SOTHER(IJ,2)=TOTHER(IJ,2)
            SOTHER(IJ,2)=TOTHER(IJ,3)
            ICN=IZSTOCN(iz,ij)
            SSOTHER(ICN,1)=TOTHER(IJ,1)
            SSOTHER(ICN,2)=TOTHER(IJ,2)
            SSOTHER(ICN,3)=TOTHER(IJ,3)
  323     continue
  
C Debug.
C          write(6,*) (TOTHER(ij,1),ij=1,10)

          call eclose(gversion(IZ),1.1,0.01,newgeo)
          if(igupgrade.eq.2.and.(.NOT.newgeo))then
            gversion(iz) =1.1
            newgeo = .true.
          endif
          if(newgeo)then
            call geowrite(IFIL+2,LGEOM(IZ),IZ,iuout,3,IER)
          else
            call emkgeo(IFIL+2,LGEOM(IZ),IZ,3,IER)
          endif
          IF(IER.NE.0)THEN
            CALL USRMSG(bl,' Problem updating geometry file.','W')
          ENDIF
        endif
  100 CONTINUE

C Ask user if updated information should be saved to different file.
 289  helptopic='save_to_cnn_file'
      call gethelptext(helpinsub,helptopic,nbhelp)
      write(DCNN,'(a,a)')cfgroot(1:lnblnk(cfgroot)),'.cnn'
      if(LCNN(1:1).eq.' ')LCNN=DCNN
      CALL EASKS(LCNN,' Surface connections file name?',' ',
     &  72,DCNN,'system connx file name',IER,nbhelp)
      IF(LCNN.EQ.' ')GOTO 289
      call EMKCFG('-',IER)

      RETURN
      END

C ************* ESACON 
C ESACON import surface connection attributes into the problem topology
C common block C3 while taking into account confirmation preferences.
C IER=0 OK, IER=1 problem.
      SUBROUTINE ESACON(M1SKP,M2SKP,M4SKP,M5SKP,M6SKP,M7SKP,IER)
#include "building.h"
#include "model.h"
#include "site.h"
#include "geometry.h"
      
      integer lnblnk  ! function definition

C Parameters: logical variables set the context of what to check
      logical M1SKP,M2SKP,M4SKP,M5SKP,M6SKP,M7SKP
      integer  IER   ! zero is ok 

      COMMON/FILEP/IFIL
      COMMON/SPAD/MMOD,LIMIT,LIMTTY
      COMMON/OUTIN/IUOUT,IUIN
      
      integer ncomp,ncon
      COMMON/C1/NCOMP,NCON
      COMMON/C24/IZSTOCN(MCOM,MS)

      COMMON/gzonpik/izgfoc,nzg,nznog(mcom)
      COMMON/RAY2/ITDSP,ITBND,ITEPT,ITZNM,ITSNM,ITVNO,ITORG,ITSNR,
     &            ITOBS,ITHLS,ITHLZ,ITGRD,GRDIS,ITPPSW
      COMMON/RAY3/MODIFY,MODLEN,MODBND
      COMMON/RAY6/LINSTY(MCON)
      common/scanpause/longpause

      COMMON/C3/IC1(MCON),IE1(MCON),ICT(MCON),IC2(MCON),IE2(MCON)
      LOGICAL OK,DOK,MODIFY,MODLEN,MODBND,close,longpause

      CHARACTER CXSTR*78,outs*124
      CHARACTER OUTSTR*124,SO*12,ZN*12,TMP*54
      CHARACTER bl*2

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='ESACON'  ! set for subroutine

C General image option flags.
      bl='  '
      ITDSP=1
      ITBND=1
      ITEPT=0
      ITZNM=0
      ITSNM=0
      ITVNO=1
      ITORG=1
      ITSNR=1
      ITGRD=1
      GRDIS=0.0

C Display connection header.
      TMP=' '
      CALL EDISP(iuout,' ')
      CALL CONXINF(1,0,CXSTR)
      CALL EDISP(iuout,CXSTR)

C Help text for the dialogs.
      helptopic='importing_surf_conn'
      call gethelptext(helpinsub,helptopic,nbhelp)

C Loop through each connection in turn. Read in the geometry
C attributes for each set of connections in turn.
C Map between the connection and surface. Only read in geometry
C and display zone when connection jumps to another zone.
      ICL=0
      DO 123 ICC=1,NCON
        CALL CONXINF(1,ICC,CXSTR)
        CALL EDISP(iuout,CXSTR)
        IF(ICL.NE.IC1(ICC))THEN
          call georead(IFIL+1,LGEOM(IC1(ICC)),IC1(ICC),1,ITRU,IER)
          MODIFY=.TRUE.
          MODBND=.TRUE.

C Set all surfaces to standard line width.
          if(MMOD.eq.8)CALL INLNST(1)
          nzg=1
          nznog(1)=IC1(ICC)
          izgfoc=IC1(ICC)
          if(MMOD.eq.8)CALL CADJVIEW(IER)
          IF(IER.NE.0)THEN
            RETURN
          ELSE
            ICL=IC1(ICC)
            ISS=0
          ENDIF
        ENDIF
        ISS=ISS+1

C If surface attribute is something other than UNKNOWN then see about 
C upgrading the current connection. Display the connection and the
C surface attribute and ask user if attribute should be used. First
C check for easy matches.
        ICN=IZSTOCN(IC1(ICC),iss)
        WRITE(SO,'(A)')SSOTHER(ICN,1)(1:12)

C Set connected zone name if one exists.
        if(IC2(ICC).ne.0)then
	  write(ZN,'(a)') zname(IC2(ICC))
        else
	  ZN='------------'
        endif
        WRITE(TMP,'(A,I3,A,A15)')'Surface ',ISS,' attribute: ',SO
        WRITE(OUTSTR,'(A,A)')'Topology: ',CXSTR(1:lnblnk(CXSTR))
        IF(SO(1:8).EQ.'EXTERIOR'.AND.ICT(ICC).EQ.0)THEN
          CALL EDISP(iuout,'   topology & attribute EXTERIOR matches.')
          goto  123
        ELSEIF(SO(1:7).EQ.'SIMILAR'.AND.ICT(ICC).EQ.1)THEN
          CALL EDISP(iuout,'   topology & attribute SIMILAR matches.')
          GOTO 123
        ELSEIF(SO(1:8).EQ.'CONSTANT'.AND.ICT(ICC).EQ.2)THEN
          CALL EDISP(iuout,'   topology & attribute CONSTANT matches.')
          GOTO 123
        ELSEIF(SO(1:6).EQ.'GROUND'.AND.ICT(ICC).EQ.4)THEN
          CALL EDISP(iuout,'   topology & attribute GROUND match.')
          GOTO 123
        ELSEIF(SO(1:9).EQ.'ADIABATIC'.AND.ICT(ICC).EQ.5)THEN
          CALL EDISP(iuout,'   topology & attribute ADIABATIC match.')
          GOTO 123
        ELSEIF(SO(1:8).EQ.'BASESIMP'.AND.ICT(ICC).EQ.6)THEN
          CALL EDISP(iuout,'   topology & attribute BASESIMP match.')
          GOTO 123
        ELSEIF(SO(1:9).EQ.'IDENT_CEN'.AND.ICT(ICC).EQ.7)THEN
          CALL EDISP(iuout,'   topology & attribute IDENT_CEN match.')
          GOTO 123
        ELSEIF(SO(1:7).EQ.'UNKNOWN'.OR.SO(1:2).EQ.'  ')THEN
          CALL EDISP(iuout,' surface attribute was UNKNOWN: skipping.')
          GOTO 123
        ELSEIF(ICT(ICC).EQ.3.AND.(SO.EQ.ZN))then
          CALL EDISP(iuout,'   connected zone names match.')
          GOTO 123
        ELSEIF(SO(1:7).EQ.'SIMILAR')THEN
          MODIFY=.TRUE.
          if(MMOD.eq.8)CALL INLNST(1)
          LINSTY(ICC)=2
          nzg=1
          nznog(1)=IC1(ICC)
          izgfoc=IC1(ICC)
          if(MMOD.eq.8)CALL CADJVIEW(IER)
          if(.NOT.M1SKP)then
            call edisp(iuout,OUTSTR)
            call edisp(iuout,TMP)
            dok=.true.
            CALL ASKOK(' ','Use this surface attribute?',OK,dok,nbhelp)
            IF(.NOT.OK)GOTO 123
          endif
          CALL EDISP(iuout,'   topology << SIMILAR.')
          if(MMOD.eq.8)then
            if(longpause)then
              call pauses(1)
            else
              call pausems(400)
            endif
          endif
          ICT(ICC)=1
          IC2(ICC)=0
          IE2(ICC)=0
          GOTO 123
        ELSEIF(SO(1:8).EQ.'CONSTANT')THEN
          MODIFY=.TRUE.
          if(MMOD.eq.8)CALL INLNST(1)
          LINSTY(ICC)=2
          nzg=1
          nznog(1)=IC1(ICC)
          izgfoc=IC1(ICC)
          if(MMOD.eq.8)CALL CADJVIEW(IER)
          if(.NOT.M2SKP)then
            call edisp(iuout,OUTSTR)
            call edisp(iuout,TMP)
            dok=.true.
            CALL ASKOK(' ','Use this surface attribute?',OK,dok,nbhelp)
            IF(.NOT.OK)GOTO 123
          endif
          CALL EDISP(iuout,'   topology << CONSTANT.')
          ICT(ICC)=2
          VAL=IC2(ICC)
          CALL EASKR(VAL,' ',' Constant temperature ? ',
     &        -99.,'F',99.,'F',20.,'adjacent temperature',IER,nbhelp)
          VAL2=IE2(ICC)
          CALL EASKR(VAL2,' ',' Constant rad (W/m^2) ? ',
     &        -999.,'F',999.,'F',0.,'adjacent rad',IER,nbhelp)
          IC2(ICC)=INT(VAL)
          IE2(ICC)=INT(VAL2)
          GOTO 123
        ELSEIF(SO(1:6).EQ.'GROUND')THEN
          MODIFY=.TRUE.
          if(MMOD.eq.8)CALL INLNST(1)
          LINSTY(ICC)=2
          nzg=1
          nznog(1)=IC1(ICC)
          izgfoc=IC1(ICC)
          if(MMOD.eq.8)CALL CADJVIEW(IER)
          if(.NOT.M4SKP)then
            call edisp(iuout,OUTSTR)
            call edisp(iuout,TMP)
            dok=.true.
            CALL ASKOK(' ','Use this surface attribute?',OK,dok,nbhelp)
            IF(.NOT.OK)GOTO 123
          endif
          CALL EDISP(iuout,'   topology << GROUND.')
          ICT(ICC)=4
          CALL EDISP(iuout,'Standard ground profiles Jan-Dec:')
          CALL EDISP(iuout,'id  Jan, Feb, Mar, Apr, May, Jun, Jul...')
          do 21 igrdp=1,mgrdp
            CALL ECLOSE(GRDTMP(6,igrdp),0.0,0.001,close)
            if(.NOT.close)then
              WRITE(OUTS,'(I2,12F5.1)')igrdp,(GRDTMP(J,IGRDP),J=1,12)
              call edisp(iuout,outs)
            endif
21        continue

C List out user defined profiles, assuming that if June is 0.0, then the
C profile has not been defined.
          if(NGRDP.gt.0)then
            CALL EDISP(iuout,' ')
            do 22 igrdp=1,NGRDP    
              CALL EDISP(iuout,'User defined ground profile Jan-Dec:')
              WRITE(OUTS,'(12F6.1)')(UGRDTP(J,IGRDP),J=1,12)
              call edisp(iuout,outs)
 22         continue
          endif
          helptopic='fill_out_ground'
          call gethelptext(helpinsub,helptopic,nbhelp)
          IVAL=1
          CALL EASKI(IVAL,' Monthly profile (0 = user defined) ? ',
     &      ' ',-3,'F',12,'F',1,'ground profile',IER,nbhelp)
          IC2(ICC)=IVAL
          IF(IC2(ICC).GT.0)THEN
            IE2(ICC)=0
          ELSEIF(IC2(ICC).eq.0)THEN
            IVAL=IE2(ICC)
            CALL EASKI(IVAL,' User defined profile: ',
     &        ' ',0,'F',9,'F',1,'user defined profile',IER,nbhelp)
            IE2(ICC)=IVAL
          ELSEIF(IC2(ICC).eq.-3)THEN
            IE2(ICC)=0
          ENDIF
          GOTO 123
        ELSEIF(SO(1:9).EQ.'ADIABATIC')THEN
          MODIFY=.TRUE.
          if(MMOD.eq.8)CALL INLNST(1)
          LINSTY(ICC)=2
          nzg=1
          nznog(1)=IC1(ICC)
          izgfoc=IC1(ICC)
          if(MMOD.eq.8)CALL CADJVIEW(IER)
          if(.NOT.M5SKP)then
            call edisp(iuout,OUTSTR)
            call edisp(iuout,TMP)
            dok=.true.
            CALL ASKOK(' ','Use this surface attribute?',
     &        OK,dok,nbhelp)
            IF(.NOT.OK)GOTO 123
          endif
          CALL EDISP(iuout,'   topology << ADIABATIC.')
          if(MMOD.eq.8)then
            if(longpause)then
              call pauses(1)
            else
              call pausems(400)
            endif
          endif
          ICT(ICC)=5
          IC2(ICC)=0
          IE2(ICC)=0
          GOTO 123
        ELSEIF(SO(1:8).EQ.'BASESIMP')THEN

C BASESIMP start.
C Get BASESIMP configuration via call to bsimtype. Save state of current
C menu and recover after the call.
          MODIFY=.TRUE.
          if(MMOD.eq.8)CALL INLNST(1)
          LINSTY(ICC)=2
          nzg=1
          nznog(1)=IC1(ICC)
          izgfoc=IC1(ICC)
          if(MMOD.eq.8)CALL CADJVIEW(IER)
          if(.NOT.M6SKP)then
            call edisp(iuout,OUTSTR)
            call edisp(iuout,TMP)
            dok=.true.
            CALL ASKOK(' ','Use this surface attribute?',
     &        OK,dok,nbhelp)
            IF(.NOT.OK)GOTO 123
          endif
          CALL EDISP(iuout,'   topology << BASESIMP.')
          if(MMOD.eq.8)then
            if(longpause)then
              call pauses(1)
            else
              call pausems(400)
            endif
          endif
          ICT(ICC)=6

C          CALL EPMENSV
          IBS=IC2(ICC)
          call bsimtype(ibs)
C           CALL EPMENRC
          IC2(ICC)=IBS

C Get `surface weighting factor', the percentage of the BASESIMP heat loss to
C attribute to the surface under consideration.
          Ifrac=IE2(ICC)
          helptopic='boundary_basesimp'
          call gethelptext(helpinsub,helptopic,nbhelp)
          CALL EASKI(Ifrac,
     &      ' Percent of BASESIMP loss to this surface?',
     &      ' ',0,'F',100,'F',100,'BASESIMP heat loss percent',
     &      IER,nbhelp)
          IE2(ICC)=Ifrac
C BASESIMP end.
          GOTO 123
        ELSEIF(SO(1:9).EQ.'IDENT_CEN')THEN
          MODIFY=.TRUE.
          if(MMOD.eq.8)CALL INLNST(1)
          LINSTY(ICC)=2
          nzg=1
          nznog(1)=IC1(ICC)
          izgfoc=IC1(ICC)
          if(MMOD.eq.8)CALL CADJVIEW(IER)
          if(.NOT.M7SKP)then
            call edisp(iuout,OUTSTR)
            call edisp(iuout,TMP)
            dok=.true.
            CALL ASKOK(' ','Use this surface attribute?',
     &        OK,dok,nbhelp)
            IF(.NOT.OK)GOTO 123
          endif
          CALL EDISP(iuout,'   topology << IDENT_CEN.')
          if(MMOD.eq.8)then
            if(longpause)then
              call pauses(1)
            else
              call pausems(400)
            endif
          endif
          ICT(ICC)=7
          IC2(ICC)=0
          IE2(ICC)=0
          GOTO 123
        ELSEIF(SO(1:8).EQ.'EXTERIOR')THEN
          MODIFY=.TRUE.
          if(MMOD.eq.8)CALL INLNST(1)
          LINSTY(ICC)=2
          nzg=1
          nznog(1)=IC1(ICC)
          izgfoc=IC1(ICC)
          if(MMOD.eq.8)CALL CADJVIEW(IER)
          call edisp(iuout,OUTSTR)
          call edisp(iuout,TMP)
          dok=.true.
          CALL ASKOK(' ','Use this surface attribute?',OK,dok,nbhelp)
          IF(.NOT.OK)GOTO 123
          CALL EDISP(iuout,'   topology << EXTERIOR.')
          if(MMOD.eq.8)then
            if(longpause)then
              call pauses(1)
            else
              call pausems(400)
            endif
          endif
          ICT(ICC)=0
          IC2(ICC)=0
          IE2(ICC)=0
        ELSE

C Not an easy match or mandated match so tell user.
          MODIFY=.TRUE.
          if(MMOD.eq.8)CALL INLNST(1)
          LINSTY(ICC)=2
          nzg=1
          nznog(1)=IC1(ICC)
          izgfoc=IC1(ICC)
          if(MMOD.eq.8)CALL CADJVIEW(IER)
          WRITE(OUTSTR,'(A,A)')'Topology: ',CXSTR(1:lnblnk(CXSTR))
          call edisp(iuout,' ')
          call edisp(iuout,OUTSTR)
          call edisp(iuout,TMP)
          CALL usrmsg(bl,'Attribute cannot be imported.','-')
          if(MMOD.eq.8)then
            if(longpause)then
              call pauses(1)
            else
              call pausems(400)
            endif
          endif
          GOTO 123
        ENDIF
  123 CONTINUE

C Ask user if updated info should be saved to file.
      dok=.true.
      CALL ASKOK(' ','Save updated topology?',OK,dok,nbhelp)
      if(OK)then
        call EMKCFG('-',IER)
      endif

      RETURN
      END

C **************** anchor 
C anchor defines and instanciates anchor points (a list of connections
C associated with a concept).
      subroutine anchor(ifoc,ier)
#include "building.h"
#include "epara.h"
      
      integer lnblnk  ! function definition

      COMMON/OUTIN/IUOUT,IUIN
      
      integer ncomp,ncon
      COMMON/C1/NCOMP,NCON
      COMMON/gzonpik/izgfoc,nzg,nznog(mcom)
      COMMON/RAY3/MODIFY,MODLEN,MODBND
      COMMON/RAY6/LINSTY(MCON)

C Anchor commons:
C NALOC = nb of anchors,
C ALOC = substitution attribute used with the the anchor (usually
C   passed from a command to a function which manipulates the anchor.),
C ALOCLBL = user's name for the anchor,
C ALOCTYP = type (SURF|CTRL|LOAD) for the anchor,
C IALOC = nb of links (surfaces, etc.) associated with the anchor,
C lstanchr = links for each anchor
      common/anchora/NALOC,ALOC(20),ALOCLBL(20),ALOCTYP(20)
      common/anchorb/IALOC(20),lstanchr(20,60)

      DIMENSION VERT(35),flag(mcon),iconnpk(60)
      CHARACTER VERT*54,KEY*1,outs*124
      character CXITM*43,flag*9
      character ALOC*12,ALOCLBL*12,ALOCTYP*4,AL*12
      logical found,ok,dok,foundone,okd,MODIFY,MODLEN,MODBND
      integer MVERT,IVERT ! max items and current menu item

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='anchor'  ! set for subroutine

C Initialise connection menu size variables based on window size. 
C IVERT is the menu position, MVERT the current number of menu lines.
  31  MHEAD=7
      MCTL=4
      ILEN=NCON
      IPACT=CREATE
      CALL EKPAGE(IPACT)

      do 2 i = 1,ncon
        flag(i)= '      '
  2   continue

C Force redraw of zones, highlighting anchor list.
      MODIFY=.TRUE.
      nzg=NCOMP
      if(nzg.gt.0)then
        DO 44 I=1,nzg
          nznog(I)=I
  44    CONTINUE
        CALL INLNST(1)
        do 45 jj = 1,IALOC(ifoc)
          kk=lstanchr(ifoc,jj)
          if(kk.ne.0)LINSTY(kk)=2
  45    continue
        CALL ADJVIEW(IER)
      endif

C Initial menu entry setup.
   92 IER=0
      IVERT=-3

C Help text.
   3  helptopic='anchor_options'
      call gethelptext(helpinsub,helptopic,nbhelp)

C Set menu header text. Update flag string with * depending on which
C anchor set(s) is/are associated with a connection.
      write(VERT(1),'(a)') '  anchor data: '
      write(VERT(2),'(a)') '  ____________________________________'
      write(VERT(3),'(a)') '  index  label    type       nb. links'
      write(VERT(4),'(a,i2,5a,i2,a)') '1 ',ifoc,' ',ALOCLBL(ifoc),' ',
     &  ALOCTYP(ifoc),' (',IALOC(ifoc),' links)'
      VERT(5)='  ___________________________________________   '
      VERT(6)=' conn|  connection      |    connection     |123456789'
      VERT(7)=' no. | inside face      | other side data   |anchor'
      do 5 i=1,NALOC
        if(IALOC(i).gt.0)then
          do 4 j = 1,IALOC(i)
            k=lstanchr(i,j)
            if(k.ne.0.and.i.eq.1)write(flag(k)(1:1),'(a)') '*'
            if(k.ne.0.and.i.eq.2)write(flag(k)(2:2),'(a)') '*'
            if(k.ne.0.and.i.eq.3)write(flag(k)(3:3),'(a)') '*'
            if(k.ne.0.and.i.eq.4)write(flag(k)(4:4),'(a)') '*'
            if(k.ne.0.and.i.eq.5)write(flag(k)(5:5),'(a)') '*'
            if(k.ne.0.and.i.eq.6)write(flag(k)(6:6),'(a)') '*'
            if(k.ne.0.and.i.eq.7)write(flag(k)(7:7),'(a)') '*'
            if(k.ne.0.and.i.eq.8)write(flag(k)(8:8),'(a)') '*'
            if(k.ne.0.and.i.ge.9)write(flag(k)(9:9),'(a)') '*'
   4      continue
        endif
   5  continue

C Loop through the items until the page to be displayed. M is the 
C current menu line index. Build up text strings for the menu. 
      M=MHEAD
      DO 10 L=1,ILEN
        IF(L.GE.IST.AND.(L.LE.(IST+MIFULL)))THEN
          M=M+1
          CALL EMKEY(L,KEY,IER)
          call CONXMENU(L,CXITM)
          VERT(M)=' '
          WRITE(VERT(M),'(A1,1x,A42,1a,a)')KEY,CXITM(1:42),'|',flag(L)
        ENDIF
   10 CONTINUE

C Number of actual items displayed.
      MVERT=M+MCTL

C If a long list include page facility text.      
      IF(IPFLG.EQ.0)THEN
        VERT(M+1)='  ________________________________________ '
      ELSE
        WRITE(VERT(M+1),15)IPM,MPM 
   15   FORMAT   ('0 page ------- Part: ',I2,' of ',I2,' -----')
      ENDIF
      VERT(M+2)  ='* modify list                         '
      VERT(M+3)  ='? help                                '
      VERT(M+4)  ='- exit this menu                      '

C Now display the menu.
      CALL EMENU('  Anchor points',VERT,MVERT,IVERT)

      if(ivert.eq.mvert)then

C Save and return. 
        if(NALOC.gt.0)CALL EMKCFG('-',IER)
        return
      elseif(ivert.eq.mvert-1)then
        helptopic='anchor_options'
        call gethelptext(helpinsub,helptopic,nbhelp)
        CALL PHELPD('anchor points',nbhelp,'-',0,0,IER)
      elseif(ivert.eq.mvert-2)then
        if(IALOC(ifoc).eq.0)then
          inpic = 60
        else
          inpic = 60 - IALOC(ifoc)
        endif
        CALL EPMENSV
        call easkconn(inpic,iconnpk,60,
     &    'Select from the list of connections the',
     &    'surfaces associated with this anchor.',ALOCLBL(ifoc),
     &    ifoc,ier,30)
        CALL EPMENRC
        if(inpic.gt.0)then
          do 242 ij=1,inpic

C For each item from iconnpk that does not match an existing
C anchor update the list.
            found=.false.
            if(IALOC(ifoc).eq.0)then
              IALOC(ifoc)=IALOC(ifoc)+1
              lstanchr(ifoc,IALOC(ifoc))=iconnpk(ij)
            else
              do 243 ik=1,IALOC(ifoc)
                if(lstanchr(ifoc,ik).eq.iconnpk(ij))found=.true.
  243         continue
              if(.NOT.found)then
                IALOC(ifoc)=IALOC(ifoc)+1
                lstanchr(ifoc,IALOC(ifoc))=iconnpk(ij)
              endif
            endif
  242     continue
          goto 31
        else
          call edisp(iuout,'No surfaces associated with anchor.')
        endif
        goto 31
      elseif(ivert.eq.mvert-3)then

C If there are enough items allow paging control via EKPAGE.
        IF(IPFLG.EQ.1)THEN
          IPACT=EDIT
          CALL EKPAGE(IPACT)
        ENDIF
      elseif(ivert.eq.4)then

C Force redraw of zones, highlighting anchor list.
        MODIFY=.TRUE.
        nzg=NCOMP
        if(nzg.gt.0)then
          DO 144 I=1,nzg
            nznog(I)=I
 144      CONTINUE
          CALL INLNST(1)
          do 145 jj = 1,IALOC(ifoc)
            kk=lstanchr(ifoc,jj)
            if(kk.ne.0)LINSTY(kk)=2
 145      continue
          CALL ADJVIEW(IER)
        endif
        dok=.false.
        call askok('Edit anchor name or type?',' ',ok,dok,nbhelp)
        if(ok)then
          ino=0
          if(ALOCTYP(ifoc)(1:4).eq.'SURF')ino=1
          if(ALOCTYP(ifoc)(1:4).eq.'CLDR')ino=2
          if(ALOCTYP(ifoc)(1:4).eq.'OPDR')ino=3
          if(ALOCTYP(ifoc)(1:4).eq.'CLWN')ino=4
          if(ALOCTYP(ifoc)(1:4).eq.'OPWN')ino=5
          if(ALOCTYP(ifoc)(1:4).eq.'CLGR')ino=6
          if(ALOCTYP(ifoc)(1:4).eq.'OPGR')ino=7
          if(ALOCTYP(ifoc)(1:4).eq.'DUCT')ino=8
          if(ALOCTYP(ifoc)(1:4).eq.'FANP')ino=9
          ilno=ino
          idno=1
          call MENUATOL('Select a type for the anchor:',
     &    'Anchor type (options)','a surface (general)','b closed door',
     &    'c open(able) door','d closed window','e open(able) window',
     &    'f closed grill','g openable grill','h duct or pipe',
     &    'i fan or pump',' ',' ',' ',ino,idno,nbhelp)
          if(ino.eq.0)then
            goto 31
          elseif(ino.eq.1)then
            AL=ALOCLBL(ifoc)
            if(AL(1:4).eq.'unde')AL='  '
            CALL EASKS(AL,' Label for anchor: ',
     &        ' ',12,'none','anchor label',IER,nbhelp)
            ALOCLBL(ifoc)=AL
            ALOCTYP(ifoc)='SURF'
          elseif(ino.eq.2)then
            if(ALOCLBL(ifoc)(1:4).eq.'unde')AL='closed_door'
            CALL EASKS(AL,'Label:',' ',12,'none','closed dr',
     &        IER,nbhelp)
            ALOCLBL(ifoc)=AL
            ALOCTYP(ifoc)='CLDR'
          elseif(ino.eq.3)then
            if(ALOCLBL(ifoc)(1:4).eq.'unde')AL='open_door'
            CALL EASKS(AL,'Label:',' ',12,'none','open dr ',
     &        IER,nbhelp)
            ALOCLBL(ifoc)=AL
            ALOCTYP(ifoc)='OPDR'
          elseif(ino.eq.4)then
            if(ALOCLBL(ifoc)(1:4).eq.'unde')AL='closed_windw'
            CALL EASKS(AL,'Label:',' ',12,'none','closd win',
     &        IER,nbhelp)
            ALOCLBL(ifoc)=AL
            ALOCTYP(ifoc)='CLWN'
          elseif(ino.eq.5)then
            if(ALOCLBL(ifoc)(1:4).eq.'unde')AL='open_window'
            CALL EASKS(AL,'Label:',' ',12,'none','open win',
     &        IER,nbhelp)
            ALOCLBL(ifoc)=AL
            ALOCTYP(ifoc)='OPWN'
          elseif(ino.eq.6)then
            if(ALOCLBL(ifoc)(1:4).eq.'unde')AL='closed_grill'
            CALL EASKS(AL,'Label:',' ',12,'none','closd grill',
     &        IER,nbhelp)
            ALOCLBL(ifoc)=AL
            ALOCTYP(ifoc)='CLGR'
          elseif(ino.eq.7)then
            if(ALOCLBL(ifoc)(1:4).eq.'unde')AL='open_grill'
            CALL EASKS(AL,'Label:',' ',12,'none','open grill',
     &        IER,nbhelp)
            ALOCLBL(ifoc)=AL
            ALOCTYP(ifoc)='OPGR'
          elseif(ino.eq.8)then
            if(ALOCLBL(ifoc)(1:4).eq.'unde')AL='duct'
            CALL EASKS(AL,'Label:',' ',12,'none','ductorpipe',
     &        IER,nbhelp)
            ALOCLBL(ifoc)=AL
            ALOCTYP(ifoc)='DUCT'
          elseif(ino.eq.9)then
            if(ALOCLBL(ifoc)(1:4).eq.'unde')AL='fanorpump'
            CALL EASKS(AL,'Label:',' ',12,'none','fanorpump',
     &        IER,nbhelp)
            ALOCLBL(ifoc)=AL
            ALOCTYP(ifoc)='FANP'
          endif
          CALL EMKCFG('-',IER)
        endif
      elseif(IVERT.GT.MHEAD.AND.IVERT.LT.(MVERT-MCTL+1))then

C Enquire about connection identified by KEYIND.
        CALL KEYIND(MVERT,IVERT,IFOCC,IO)

C Display information about the anchors associated with connection.
        call CONXMENU(ifocc,CXITM)
        write(outs,'(a,a)') CXITM(1:lnblnk(CXITM)),
     &    ' is associated with the following anchors...'
        call edisp(iuout,outs)
        outs=' '
        foundone=.false.
        do 6 i=1,NALOC
          if(IALOC(i).gt.0)then
            do 7 j = 1,IALOC(i)
              k=lstanchr(i,j)
              if(k.eq.ifocc.and.i.gt.0)then
                foundone=.true.
                write(outs(1:12),'(a,a)') ALOCLBL(i)
                call edisp(iuout,outs)
              endif
   7        continue
          endif
   6    continue
        if(foundone)then
          dok=.false.
          call askok('De-reference link(s) to this surface?',' ',
     &      ok,dok,nbhelp)
          if(ok)then

C Loop through all of the anchor lists and check if any reference this
C connection. If use requests deletion, shift list (lstanchr) and
C decrement IALOC.
            do 16 i=1,NALOC
              ikk=IALOC(i)
              if(ikk.gt.0)then
                do 17 j = 1,ikk
                  k=lstanchr(i,j)
                  if(k.eq.ifocc)then
                   write(outs,'(3a)')'Dereference ',ALOCLBL(i),'?'
                    dok=.true.
                    call askok(outs,' ',okd,dok,nbhelp)
                    if(okd)then
                      do 18 ik=j,ikk-1
                        lstanchr(i,j)=lstanchr(i,j+1)
  18                  continue
                      IALOC(i)=IALOC(i)-1
                    endif
                  endif
  17            continue
              endif
  16        continue
            goto 31
          endif
        endif
C << what additional functionality?? >>
      else
        ivert=-1
        goto 92
      endif
      ivert=-4
      goto 3

      end

C **************** anchlist 
C anchlist allows selection and list management of anchor points (a list of connections
C associated with a concept).
      subroutine anchlist(iasel,ier)
      COMMON/SPAD/MMOD,LIMIT,LIMTTY

      common/anchora/NALOC,ALOC(20),ALOCLBL(20),ALOCTYP(20)
      common/anchorb/IALOC(20),lstanchr(20,60)

      DIMENSION AVERT(27)
      CHARACTER AVERT*36,KEY*1
      character ALOC*12,ALOCLBL*12,ALOCTYP*4,AL*12
      integer MVERT,IVERT ! max items and current menu item

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='anchlist'  ! set for subroutine

      iasel=0

C Initialise connection menu size variables based on window size. 
C IVERT is the menu position, MVERT the current number of menu lines.
      if(NALOC.eq.0)then
        call usrmsg('Currently there are no anchors defined. ',
     &    'Begin by selecting the + option. ','W')
      endif
  31  MHEAD=3
      MCTL=4

C Debug
C      write(6,*) 'naloc mhead mctl ',naloc,mhead,mctl

C Initial menu entry setup.
   92 IER=0
      IVERT=-3

C Help text.
   3  helptopic='anchor_choices'
      call gethelptext(helpinsub,helptopic,nbhelp)

C Set menu header text.
      write(AVERT(1),'(a,i2)') '1 anchors: ',NALOC
      write(AVERT(2),'(a)')    '  ________________________________ '
      write(AVERT(3),'(a)')    '  index  label     type  links     '
      M=MHEAD
      do 5 L=1,NALOC
        M=M+1
        CALL EMKEY(L,KEY,IER)
        AVERT(M)=' '
        write(AVERT(M),'(2a,i2,5a,i2,a)') KEY,' ',L,'   ',ALOCLBL(L),
     &  ' ',ALOCTYP(L),' (',IALOC(L),' links)'
   5  continue

C Number of actual items displayed.
      MVERT=M+MCTL

C If a long list include page facility text.      
      AVERT(M+1)  ='  ________________________________ '
      AVERT(M+2)  ='+ add/delete an anchor             '
      AVERT(M+3)  ='? help                             '
      AVERT(M+4)  ='- exit this menu                   '

C Now display the menu.
      if(mmod.eq.8)then
        CALL EMENU('  Current anchor points',AVERT,MVERT,IVERT)
      else
        CALL EMENU('  Anchor points',AVERT,MVERT,IVERT)
      endif

      if(ivert.eq.mvert)then

C Save and return. 
        if(NALOC.gt.0)CALL EMKCFG('-',IER)
        return
      elseif(ivert.eq.mvert-1)then
        helptopic='anchor_choices'
        call gethelptext(helpinsub,helptopic,nbhelp)
        CALL PHELPD('anchor points',nbhelp,'-',0,0,IER)
      elseif(ivert.eq.mvert-2)then
        CALL EASKABC('Anchor point options:',' ',
     &    'add an anchor','delete an anchor','contine',II,nbhelp)
        if(II.eq.1)then
          NALOC=NALOC+1
          ino=0
          ilno=0
          idno=3
          call MENUATOL('Select a type for the anchor:',
     &    'Anchor type (options)','a surface (general)','b closed door',
     &    'c open(able) door','d closed window','e open(able) window',
     &    'f closed grill','g openable grill','h duct or pipe',
     &    'i fan or pump',' ',' ',' ',ino,idno,nbhelp)
          if(ino.eq.0)then
            goto 31
          elseif(ino.eq.1)then
            AL=ALOCLBL(NALOC)
            CALL EASKS(AL,' Label for anchor: ',
     &        ' ',12,'none','anchor label',IER,nbhelp)
            ALOCLBL(NALOC)=AL
            ALOCTYP(NALOC)='SURF'
          elseif(ino.eq.2)then
            if(ALOCLBL(NALOC)(1:4).eq.'unde')AL='closed_door'
            CALL EASKS(AL,'Label:',' ',12,'none','closed dr',
     &        IER,nbhelp)
            ALOCLBL(NALOC)=AL
            ALOCTYP(NALOC)='CLDR'
          elseif(ino.eq.3)then
            if(ALOCLBL(NALOC)(1:4).eq.'unde')AL='open_door'
            CALL EASKS(AL,'Label:',' ',12,'none','open dr ',
     &        IER,nbhelp)
            ALOCLBL(NALOC)=AL
            ALOCTYP(NALOC)='OPDR'
          elseif(ino.eq.4)then
            if(ALOCLBL(NALOC)(1:4).eq.'unde')AL='closed_windw'
            CALL EASKS(AL,'Label:',' ',12,'none','closd win',
     &        IER,nbhelp)
            ALOCLBL(NALOC)=AL
            ALOCTYP(NALOC)='CLWN'
          elseif(ino.eq.5)then
            if(ALOCLBL(NALOC)(1:4).eq.'unde')AL='open_window'
            CALL EASKS(AL,'Label:',' ',12,'none','open win',
     &        IER,nbhelp)
            ALOCLBL(NALOC)=AL
            ALOCTYP(NALOC)='OPWN'
          elseif(ino.eq.6)then
            if(ALOCLBL(NALOC)(1:4).eq.'unde')AL='closed_grill'
            CALL EASKS(AL,'Label:',' ',12,'none','closd grill',
     &        IER,nbhelp)
            ALOCLBL(NALOC)=AL
            ALOCTYP(NALOC)='CLGR'
          elseif(ino.eq.7)then
            if(ALOCLBL(NALOC)(1:4).eq.'unde')AL='open_grill'
            CALL EASKS(AL,'Label:',' ',12,'none','open grill',
     &        IER,nbhelp)
            ALOCLBL(NALOC)=AL
            ALOCTYP(NALOC)='OPGR'
          elseif(ino.eq.8)then
            if(ALOCLBL(NALOC)(1:4).eq.'unde')AL='duct'
            CALL EASKS(AL,'Label:',' ',12,'none','ductorpipe',
     &        IER,nbhelp)
            ALOCLBL(NALOC)=AL
            ALOCTYP(NALOC)='DUCT'
          elseif(ino.eq.9)then
            if(ALOCLBL(NALOC)(1:4).eq.'unde')AL='fanorpump'
            CALL EASKS(AL,'Label:',' ',12,'none','fanorpump',
     &        IER,nbhelp)
            ALOCLBL(NALOC)=AL
            ALOCTYP(NALOC)='FANP'
          endif
          call usrmsg('You may now associate surfaces with this',
     &      'anchor... Begin by selecting from the list. ','W')
          iasel=NALOC
          if(NALOC.gt.0)CALL EMKCFG('-',IER)
          call anchor(iasel,ier)
          goto 31
        elseif(II.eq.2)then

C Deletion function. << to be done >>

        elseif(II.eq.3)then
          continue
        endif
        goto 31
      elseif(IVERT.GT.MHEAD.AND.IVERT.LT.(MVERT-MCTL+1))then

C Pass one back for selection and manipulation.
        iasel=ivert-MHEAD
        call anchor(iasel,ier)
        goto 31
      else
        ivert=-1
        goto 92
      endif
      ivert=-4
      goto 3

      end

C **************** easkconn 
C Select one or more connections from a list.
      subroutine easkconn(inpic,iconnpk,lconnpk,promp1,promp2,ermsg,
     &  ltype,ier,nhelp)
#include "building.h"
#include "epara.h"
      
      integer lnblnk  ! function definition

      integer ncomp,ncon
      COMMON/C1/NCOMP,NCON
      common/anchorb/IALOC(20),lstanchr(20,60)

      DIMENSION iconnpk(lconnpk),VERT(35),flag(mcon)
      CHARACTER*(*) PROMP1,PROMP2,ERMSG
      CHARACTER VERT*54,KEY*1,CXITM*43,flag*1,SEL*50
      logical found
      integer MVERT,IVERT ! max items and current menu item
    
C At this point bring up a menu with the string alternatives, assuming
C there is more than one alternative to pick from.
      IF(lconnpk.LT.1)THEN
        CALL USRMSG(PROMP1,' Nunber of items to small.','W')
        IER=1
        RETURN
      ENDIF
      CALL USRMSG(PROMP1,PROMP2,'-')

C Initialise connection menu size variables based on window size. 
C IVERT is the menu position, MVERT the current number of menu lines.
      MHEAD=2
      MCTL=3
      ILEN=NCON
      IPACT=CREATE
      CALL EKPAGE(IPACT)
      IALLOW=INPIC

C Clear iconnpk and INPIC and, if editing an existing anchor, point
C to those items already associated.
      IER=0
      INPIC=0
      DO 40 I=1,lconnpk
        iconnpk(I)=0
   40 CONTINUE
      if(IALOC(ltype).gt.0)then
        do 42 ia=1,IALOC(ltype)
          if(lstanchr(ltype,ia).ne.0)then
            iconnpk(ia)=lstanchr(ltype,ia)
          endif
  42    continue
      endif

C If previous list being edited, marke these.
      do 2 i = 1,ncon
        flag(i)= ' '
        if(IALOC(ltype).gt.0)then
          do 41 ia=1,IALOC(ltype)
            if(lstanchr(ltype,ia).eq.i)then
              flag(i)= '*'
            endif
  41      continue
        endif
  2   continue

C Initial menu entry setup.
   92 IER=0
      IVERT=-3

C Set menu header text. Update flag string with * depending on which
C items have been selected. Generate text for title.
    3 lne=LNBLNK(ERMSG)
      IF(lne.GT.50)WRITE(SEL,'(1X,A)')ERMSG(1:50)
      IF(lne.LE.50)WRITE(SEL,'(1X,A)')ERMSG(1:lne)
      VERT(1)=  ' no. | inside face     | other side data   |anchor'
      VERT(2)=  ' conn|  connection     |    connection     |select'

C Loop through the items until the page to be displayed. M is the 
C current menu line index. Build up text strings for the menu. 
      M=MHEAD
      DO 10 L=1,ILEN
        IF(L.GE.IST.AND.(L.LE.(IST+MIFULL)))THEN
          M=M+1
          CALL EMKEY(L,KEY,IER)
          call CONXMENU(L,CXITM)
          VERT(M)=' '
          WRITE(VERT(M),'(A1,1x,A43,1x,a1)')KEY,CXITM,flag(L)
        ENDIF
   10 CONTINUE

C Number of actual items displayed.
      MVERT=M+MCTL

C If a long list include page facility text.      
      IF(IPFLG.EQ.0)THEN
        VERT(M+1)='  ________________________________________ '
      ELSE
        WRITE(VERT(M+1),15)IPM,MPM 
   15   FORMAT   ('0 page ------- Part: ',I2,' of ',I2,' -----')
      ENDIF
      VERT(M+2)  ='? help                                '
      VERT(M+3)  ='- exit this menu                      '

C Now display the menu.
      CALL EMENU(sel,VERT,MVERT,IVERT)

      if(IVERT.LE.MHEAD)then

C Within the header so skip request.
        IVERT=-1
        goto 3
      elseif(ivert.eq.mvert)then
        return
      elseif(ivert.eq.mvert-1)then

C Produce help text for the menu.
        CALL PHELPD('connection pick string',NHELP,'-',0,0,IER)
      elseif(ivert.eq.mvert-2)then

C If there are enough items allow paging control via EKPAGE.
        IF(IPFLG.EQ.1)THEN
          IPACT=EDIT
          CALL EKPAGE(IPACT)
        ENDIF
      elseif(IVERT.GT.MHEAD.AND.IVERT.LT.(MVERT-MCTL+1))then

C Mark identified by KEYIND. Increment ialoc counter and then
C instanciate iconnpk with current connection number. If item
C already selected, treat second selection as a toggle OFF.
        CALL KEYIND(MVERT,IVERT,IFOC,IO)
        FOUND=.FALSE.
        IF(INPIC.GT.0)THEN
          DO 44 J=1,INPIC
            if(iconnpk(J).EQ.IFOC)then
              FOUND=.TRUE.
              ljfoc=iconnpk(j)
              lj=j
            endif
  44      CONTINUE
          if(.NOT.FOUND)then
            INPIC=INPIC+1
            iconnpk(INPIC)=IFOC
            flag(ifoc)='*'
          else
            INPIC=INPIC-1
            iconnpk(lj)=0
            flag(ljfoc)=' '
          endif
        ELSEIF(INPIC.EQ.0)THEN
          INPIC=1
          iconnpk(INPIC)=IFOC
          flag(ifoc)='*'
        ENDIF
        IF(INPIC.EQ.IALLOW)THEN

C Have picked as many as are allowed.
          RETURN
        ELSE
          IVERT=-2
          goto 3
        ENDIF
      else
        ivert=-1
        goto 92
      endif
      ivert=-4
      goto 3

      end

C ***** PROCGDST
C PROCGDST process GDST command sets (defined in common blocks
C idsta and anchora.
C << Note: this procedure is somewhat out of date. Its function
C << should be reviewed for current simulation demands
      subroutine procgdst(itrc,runmode,keepres,donegdst,ier)
#include "building.h"
#include "model.h"
#include "geometry.h"
#include "esprdbfile.h"
#include "material.h"
#include "espriou.h"  
C espriou.h for climatelist file name.
      
      integer lnblnk  ! function definition

      COMMON/FILEP/IFIL
      COMMON/OUTIN/IUOUT,IUIN
      common/appw/iappw,iappx,iappy
      
      integer ncomp,ncon
      COMMON/C1/NCOMP,NCON
      COMMON/C3/IC1(MCON),IE1(MCON),ICT(MCON),IC2(MCON),IE2(MCON)
      common/C21/IFCFG,cfgroot,LCFGF
      COMMON/C24/IZSTOCN(MCOM,MS)

C IDST tool commands.
      common/idsta/CMDCFG,CMDCLM,CMDCLMN,CMDNOTE,CMDRES,CMDLBL(10),
     &             CMDLNAM(10)
      common/idstb/nidst
      common/anchora/NALOC,ALOC(20),ALOCLBL(20),ALOCTYP(20)
      common/anchorb/IALOC(20),lstanchr(20,60)
      common/spflres/sblres(MSPS),sflres(MSPS),splres(MSPS),
     &  smstres(MSPS),selres(MSPS),sipvres

      character CMDCFG*72,CMDCLM*72,CMDCLMN*72,CMDNOTE*64,CMDRES*72
      character CMDLNAM*80,CMDLBL*12
      character LCFGF*72,cfgroot*24
      character CXITM*43,outs*124,LTMP*72
      character clmdb*144
      character doit*248,tmode*8,aut*8,runmode*12,keepres*4
      character sblres*72,sflres*72,splres*72,smstres*72,sipvres*72
      character selres*72,alias*32,donegdst*72
      character longtfile*144,longtfiledos*144
      character ALOC*12,ALOCLBL*12,ALOCTYP*4
      logical updatecon,QUIET,concat,unixok
      logical newgeo  ! to use for testing if new/old geometry file.
      integer ier

#ifdef OSI
      integer ICPMOD     ! passed from tchild
#else
      integer*8 ICPMOD     ! passed from tchild
#endif

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='procgdst'  ! set for subroutine

C Set flag for zone construction file update.
      updatecon=.false.
      newgeo=.false.  ! assume older format geometry.

C Check if Unix-based or DOS based.
      call isunix(unixok)

C If IDST climate is different update the configuration. Check
C against the climate list to see related db for climate name.
      iuf=IFIL+1
      write(alias,'(a)')CMDCLMN(1:lnblnk(CMDCLMN))
      call matchcdb(iuf,alias,clmdb,ier)
      if(clmdb(1:lnblnk(clmdb)).ne.LCLIM(1:lnblnk(LCLIM)))then
        if(clmdb(1:4).ne.'UNKN')then
          LCLIM=clmdb

C Debug.
C          write(6,*)'using new climate db ',clmdb

          call tstamp('>','PRJ: IDST update climate in configuration')
          call tstamp('>',LCFGF)
          CALL EMKCFG('-',IER)
        endif
      endif

C Loop through anchor types and deal with known types.
      call edisp(iuout,' no. |zone|surf|type|   other side data')
      call edisp(iuout,' conn|reference|conn|      connection  ')
      do 32 m=1,nidst

C Now see if can match the IDST ext_window parameter. ALOC(m).
        imlcrepl=0
        do 33 k=1,NMLC
          if(ALOC(m)(1:12).eq.DESC(k)(1:12))then
            imlcrepl=k
          endif
  33    continue
        if(CMDLBL(m)(1:10).eq.'ext_window')then

C If replacement mlc found then loop through anchor points and update
C surface attributes by reading in the zone geometry, changing the
C variable ssmlcn and ssotr and then writing out the geometry file
C again. Also set updatecon to true so that construction files are
C updated as well.
          if(imlcrepl.ne.0)then
            do 34 i=1,nidst
              if(ALOCLBL(i)(1:10).eq.'ext_window')then
                call edisp(iuout,' for type ext_window...')
                do 243 j=1,IALOC(i)
                  ifoc=lstanchr(i,j)
                  call CONXMENU(ifoc,CXITM)
                  call usrmsg(' Processing...',CXITM,'-')
                  iz=ic1(ifoc)
                  is=ie1(ifoc)
                  icc=izstocn(iz,is)
                  LTMP=LGEOM(IZ)
                  call georead(IUF,LTMP,IZ,1,iuout,IER)
                  WRITE(SSMLCN(icc),'(A12)')DESC(imlcrepl)(1:12)
                 if(DESC(imlcrepl)(15:18).NE.'OPAQ')SSOTF(icc)='TRAN'
                 if(DESC(imlcrepl)(15:18).EQ.'OPAQ')SSOTF(icc)='OPAQUE'
                 if(DESC(imlcrepl)(15:18).EQ.'CFC ')SSOTF(icc)='CFC '
                  updatecon=.true.
                  call eclose(gversion(IZ),1.1,0.01,newgeo)
                  if(igupgrade.eq.2.and.(.NOT.newgeo))then
                    gversion(iz) =1.1
                    newgeo = .true.
                  endif
                  if(newgeo)then
                    call geowrite(IUF,LTMP,IZ,iuout,3,IER)
                  else
                    call emkgeo(IUF,LTMP,IZ,3,IER)
                  endif
 243            continue
              endif
  34        continue
          endif
        elseif(CMDLBL(m)(1:10).eq.'int_window')then

C If replacement mlc found then loop through anchor points and update
C surface attributes. Similar logic to the 'ext_window' case above.
          if(imlcrepl.ne.0)then
            do 44 i=1,nidst
              if(ALOCLBL(i)(1:10).eq.'int_window')then
                call edisp(iuout,' of type int_window...')
                do 244 j=1,IALOC(i)
                  ifoc=lstanchr(i,j)
                  call CONXMENU(ifoc,CXITM)
                  call usrmsg(' Processing...',CXITM,'-')
                  iz=ic1(ifoc)
                  is=ie1(ifoc)
                  icc=izstocn(iz,is)
                  LTMP=LGEOM(IZ)
                  call georead(IUF,LTMP,IZ,1,iuout,IER)
                  WRITE(SSMLCN(icc),'(A12)')DESC(imlcrepl)(1:12)
                 if(DESC(imlcrepl)(15:18).NE.'OPAQ')SSOTF(icc)='TRAN'
                 if(DESC(imlcrepl)(15:18).EQ.'OPAQ')SSOTF(icc)='OPAQUE'
                 if(DESC(imlcrepl)(15:18).EQ.'CFC ')SSOTF(icc)='CFC '
                  updatecon=.true.
                  call eclose(gversion(IZ),1.1,0.01,newgeo)
                  if(igupgrade.eq.2.and.(.NOT.newgeo))then
                    gversion(iz) =1.1
                    newgeo = .true.
                  endif
                  if(newgeo)then
                    call geowrite(IUF,LTMP,IZ,iuout,3,IER)
                  else
                    call emkgeo(IUF,LTMP,IZ,3,IER)
                  endif
 244            continue
              endif
  44        continue
          endif
        elseif(CMDLBL(m)(1:10).eq.'atr_window')then

C If replacement mlc found then loop through anchor points and update
C surface attributes. Similar logic to the 'ext_window' case above.
          if(imlcrepl.ne.0)then
            do 45 i=1,nidst
              if(ALOCLBL(i)(1:10).eq.'atr_window')then
                call edisp(iuout,' of type atr_window...')
                do 245 j=1,IALOC(i)
                  ifoc=lstanchr(i,j)
                  call CONXMENU(ifoc,CXITM)
                  call usrmsg(' Processing...',CXITM,'-')
                  iz=ic1(ifoc)
                  is=ie1(ifoc)
                  icc=izstocn(iz,is)
                  LTMP=LGEOM(IZ)
                  call georead(IUF,LTMP,IZ,1,iuout,IER)
                  WRITE(SSMLCN(icc),'(A12)')DESC(imlcrepl)(1:12)
                 if(DESC(imlcrepl)(15:18).NE.'OPAQ')SSOTF(icc)='TRAN'
                 if(DESC(imlcrepl)(15:18).EQ.'OPAQ')SSOTF(icc)='OPAQUE'
                 if(DESC(imlcrepl)(15:18).EQ.'CFC ')SSOTF(icc)='CFC '
                  updatecon=.true.
                  call eclose(gversion(IZ),1.1,0.01,newgeo)
                  if(igupgrade.eq.2.and.(.NOT.newgeo))then
                    gversion(iz) =1.1
                    newgeo = .true.
                  endif
                  if(newgeo)then
                    call geowrite(IUF,LTMP,IZ,iuout,3,IER)
                  else
                    call emkgeo(IUF,LTMP,IZ,3,IER)
                  endif
 245            continue
              endif
  45        continue
          endif
        endif
  32  continue

C If attributes changed then zone construction files should be
C re-generated via call to edcon.
      if(updatecon)then
        call tstamp('>','PRJ: IDST update zone constructions')
        QUIET=.TRUE.
        DO 2491, IZ=1,NCOMP
          CALL EDCON(0,iuout,IZ,QUIET,IER)
 2491   CONTINUE
        QUIET=.FALSE.
      endif

C Run the appropriate simulations.

C << this is similar to code within prj.F subroutine simula >>
C << consider combining these code blocks  >>

      helptopic='interactive_ipv'
      call gethelptext(helpinsub,helptopic,nbhelp)
      if(runmode(1:11).eq.'interactive')then
        CALL EASKAB('Simulation interaction options: (see help)',
     &    ' ','run interactively','silent running mode',isauto,nbhelp)
      else
        isauto=2
      endif
      call tstamp('>','PRJ: beginning IPV simulations.')
      doit = ' '
      call tchild(ICPMOD)
      call termode(ICPMOD,tmode)
      if(isauto.eq.1)aut=' default'
      if(isauto.eq.2)then
        aut=' silent '
        tmode='text'
      endif
      if(unixok)then
        call addpath(LCFGF,longtfile,concat)
      else

C If running on a non-unix machine see if there are spaces in the name
C and change any / to \.
        call addpath(LCFGF,longtfile,concat)
        call cmdfiledos(longtfile,longtfiledos,ier)
        longtfile=' '
        longtfile=longtfiledos
      endif

C If prj initial size is a % of default pass this on to child with
C an offset from prj start position.
      if(iappw.gt.0.and.iappw.le.200)then
        write(doit,'(3a,3i4,5a)') 'bps -mode ',tmode,
     &    ' -s ',iappw,iappx+15,iappy+50,' -file ',
     &    longtfile(:lnblnk(longtfile)),' -p win',aut
      else
        write(doit,'(8a)') 'bps -mode ',tmode,' -s 0 0 0 -file ',
     &   longtfile(1:lnblnk(longtfile)),' -p win',aut
      endif
      call usrmsg('starting winter assessment via',doit,'-')
      call runit(doit,tmode)
      call edisp(iuout,' ')
      call edisp(iuout,'Winter season run complete.')
      write(outs,'(a,a)')'IPV intermediate results file should be:',
     &  sipvres(1:lnblnk(sipvres))
      call edisp(iuout,outs)

      if(iappw.gt.0.and.iappw.le.200)then
        write(doit,'(3a,3i4,4a)') 'res -mode ',tmode,
     &    ' -s ',iappw,iappx+15,iappy+50,' -file ',
     &    sblres(1)(1:lnblnk(sblres(1))),' -act ipv_win ',aut
      else
        write(doit,'(6a)') 'res -mode ',tmode,
     &   ' -s 0 0 0 -file ',sblres(1)(1:lnblnk(sblres(1))),
     &   ' -act ipv_win ',aut
      endif
      call usrmsg('starting winter recovery via',doit,'-')
      call runit(doit,tmode)
      call edisp(iuout,'Winter season results complete.')

      if(iappw.gt.0.and.iappw.le.200)then
        write(doit,'(3a,3i4,5a)') 'bps -mode ',tmode,
     &    ' -s ',iappw,iappx+15,iappy+50,' -file ',
     &    longtfile(1:lnblnk(longtfile)),' -p trn',aut
      else
        write(doit,'(8a)') 'bps -mode ',tmode,' -s 0 0 0 -file ',
     &    longtfile(1:lnblnk(longtfile)),' -p trn',aut
      endif
      call usrmsg('starting transition assessment via',doit,'-')
      call runit(doit,tmode)
      call edisp(iuout,'Transition season run complete.')

      write(outs,'(a,a)')'IPV intermediate results file should be:',
     &  sipvres(1:lnblnk(sipvres))
      call edisp(iuout,outs)
      if(iappw.gt.0.and.iappw.le.200)then
        write(doit,'(3a,3i4,4a)') 'res -mode ',tmode,
     &    ' -s ',iappw,iappx+15,iappy+50,' -file ',
     &    sblres(2)(1:lnblnk(sblres(2))),' -act ipv_trn ',aut
      else
        write(doit,'(6a)') 'res -mode ',tmode,
     &   ' -s 0 0 0 -file ',sblres(2)(1:lnblnk(sblres(2))),
     &   ' -act ipv_trn ',aut
      endif
      call usrmsg('starting transition recovery via',doit,'-')
      call runit(doit,tmode)
      call edisp(iuout,'Transition season results complete.')

      if(iappw.gt.0.and.iappw.le.200)then
        write(doit,'(3a,3i4,5a)') 'bps -mode ',tmode,
     &    ' -s ',iappw,iappx+15,iappy+50,' -file ',
     &    longtfile(1:lnblnk(longtfile)),' -p sum',aut
      else
        write(doit,'(8a)') 'bps -mode ',tmode,' -s 0 0 0 -file ',
     &   longtfile(1:lnblnk(longtfile)),' -p sum',aut
      endif
      call usrmsg('starting summer assessment via',doit,'-')
      call runit(doit,tmode)
      call edisp(iuout,'Summer season run complete.')

      write(outs,'(a,a)')'IPV intermediate results file should be:',
     &  sipvres(1:lnblnk(sipvres))
      call edisp(iuout,outs)
      if(iappw.gt.0.and.iappw.le.200)then
        write(doit,'(3a,3i4,4a)') 'res -mode ',tmode,
     &    ' -s ',iappw,iappx+15,iappy+50,' -file ',
     &    sblres(3)(1:lnblnk(sblres(3))),' -act ipv_sum ',aut
      else
        write(doit,'(6a)') 'res -mode ',tmode,
     &   ' -s 0 0 0 -file ',sblres(3)(1:lnblnk(sblres(3))),
     &   ' -act ipv_sum ',aut
      endif
      call edisp(iuout,doit)
      call runit(doit,tmode)
      call edisp(iuout,'Summer season results complete.')

      call edisp(iuout,'Annual IPV recovery starting...')
      if(iappw.gt.0.and.iappw.le.200)then
        write(doit,'(3a,3i4,4a)') 'res -mode ',tmode,
     &    ' -s ',iappw,iappx+15,iappy+50,' -file ',
     &    sblres(3)(1:lnblnk(sblres(3))),' -act ipv_ann ',aut
      else
        write(doit,'(6a)') 'res -mode ',tmode,
     &   ' -s 0 0 0 -file ',sblres(3)(1:lnblnk(sblres(3))),
     &   ' -act ipv_ann ',aut
      endif
      call edisp(iuout,doit)
      call runit(doit,tmode)
      call edisp(iuout,'Summer season results complete.')

C Remove the esp-r results files if requested.
C << only do this for the actual number of sets >>
      if(keepres(1:2).eq.'no')then
        idf=ifil+1
        nzrl = MZRL
        CALL ERPFREE(idf,ISTAT)
        ier=0
        call EFOPRAN(idf,sblres(1),nzrl,1,IER)
        CALL EFDELET(idf,ISTAT)
        CALL ERPFREE(idf,ISTAT)
        call EFOPRAN(idf,sblres(2),nzrl,1,IER)
        CALL EFDELET(idf,ISTAT)
        CALL ERPFREE(idf,ISTAT)
        call EFOPRAN(idf,sblres(3),nzrl,1,IER)
        CALL EFDELET(idf,ISTAT)
        call edisp(iuout,'ESP-r results libraries cleaned up.')
      endif

      call edisp(iuout,'GDST COMMANDS FINISHED.')
      return

C 3    CALL ERPFREE(idf,ISTAT)
C      return

      end

C ******** serchrpl
C Serchrpl handles search and replace of composition attributes.
      subroutine serchrpl(act,itrc,ier)
#include "building.h"
#include "model.h"
#include "geometry.h"
#include "esprdbfile.h"
#include "material.h"
      
      integer lnblnk  ! function definition

      COMMON/FILEP/IFIL
      common/OUTIN/IUOUT,IUIN
      common/RAY3/MODIFY,MODLEN,MODBND
      
      integer ncomp,ncon
      common/C1/NCOMP,NCON
      COMMON/C3/IC1(MCON),IE1(MCON),ICT(MCON),IC2(MCON),IE2(MCON)
      COMMON/C24/IZSTOCN(MCOM,MS)

      common/anchora/NALOC,ALOC(20),ALOCLBL(20),ALOCTYP(20)
      common/anchorb/IALOC(20),lstanchr(20,60)

      logical OK,DOK,MODIFY,MODLEN,MODBND,QUIET,apply
      logical newgeo  ! to use for testing if new/old geometry file.

      dimension IVALS(MCOM)
C     dimension SNA(MS),PAZI(MS),PELV(MS)

      character LTMP*72
      character ZN*12,outs*124,SN*12
      character DESCRC*25,act*1
      character ALOC*12,ALOCLBL*12,ALOCTYP*4
      character AL1*12,AL2*12,AL3*12,AL4*12,AL5*12,AL6*12,AL7*12
      character AL8*12,AL9*12,CXITM*43
      integer ltype,ins2,ins3   ! for radio buttons

C For help messages
      character helpinsub*24 ! subroutine name
      character helptopic*24 ! string (unique) for topic
      integer nbhelp     ! number of help lines found

      helpinsub='serchrpl'  ! set for subroutine

      iuf=IFIL+1
      newgeo=.false.  ! assume older format geometry.
      if(act.eq.'c')then
        helptopic='search_constructions'
        call gethelptext(helpinsub,helptopic,nbhelp)
        CALL PHELPD('global attributions',nbhelp,'-',0,0,IER)
        if(NALOC.gt.0)then
          CALL EASKABC(' Surfaces to update:',' ',
     &      'which match a construction','linked with an anchor',
     &      'cancel',ins9,nbhelp)
        else
          ins9=1
        endif
        if(ins9.eq.1)then

C Search and replace by finding matching constructions.
          CALL EPKMLC(ISEL,'Select a construction to SEARCH for',
     &      'or -Exit',IER)
          if(ISEL.eq.0)return
          CALL EPKMLC(ISELR,'Select a construction to REPLACE it',
     &      'with or -Exit',IER)
          if(ISELR.eq.0)return

          INPIC=NCOMP
          CALL EPICKS(INPIC,IVALS,' ',' Search zones:',
     &      12,NCOMP,zname,' zone list',IER,nbhelp)
          IF(INPIC.EQ.0)return
          call tstamp('>','PRJ: global search & replace')
          DO 96 IZ=1,INPIC
            IF(IVALS(IZ).GT.0)THEN
              write(zn,'(A)') zname(IVALS(IZ))
              write(outs,'(3a)') ' Updating: ',zn(1:lnblnk(zn)),
     &           ' attributes...'
              CALL USRMSG(' ',outs,'-')
              LTMP=LGEOM(IVALS(IZ))
              call georead(IUF,LTMP,IVALS(IZ),1,iuout,IER)

              WRITE(outs,93)
              call edisp(iuout,outs)
              WRITE(outs,94)
              call edisp(iuout,outs)
              do 91 i=1,nsur
                icc=izstocn(ivals(iz),i)
                if(SSMLCN(icc)(1:12).eq.DESC(ISEL)(1:12))then
                  write(sn,'(a)') SSNAME(icc)
                  WRITE(outs,'(a7,I3,1X,F7.2,F5.0,F5.0,1X,A12,1X,A4,
     &              1X,A4,1X,A12,1X,A13)')'Match: ',I,SSNA(icc),
     &              SSPAZI(icc),SSPELV(icc),SN,SSOTF(icc)(1:4),
     &              SSVFC(icc),SSMLCN(icc)(1:12),SSOTHER(icc,1)(1:13)
                  call edisp(iuout,outs)
                  write(outs,'(5a)') ' Apply construction to ',
     &              zn(1:lnblnk(zn)),':',sn(1:lnblnk(sn)),'?'
                  dok=.true.
                  CALL ASKOK(' ',outs,OK,dok,nbhelp)
                  IF(OK)then
                    ioc=IZSTOCN(IVALS(IZ),i)
                    WRITE(SSMLCN(ioc),'(A12)')DESC(ISELR)(1:12)

C << If newgeometry then can write out the optical property instead
C << of TRAN for SSOTF.
                    if(DESC(ISELR)(15:18).NE.'OPAQ')SSOTF(ioc)='TRAN'
                    if(DESC(ISELR)(15:18).EQ.'OPAQ')SSOTF(ioc)='OPAQUE'
                    if(DESC(ISELR)(15:18).EQ.'CFC ')SSOTF(ioc)='CFC '
                  endif
                endif
 91           continue
              call eclose(gversion(IVALS(IZ)),1.1,0.01,newgeo)
              if(igupgrade.eq.2.and.(.NOT.newgeo))then
                gversion(IVALS(IZ)) =1.1
                newgeo = .true.
              endif
              if(newgeo)then
                call geowrite(IUF,LTMP,IVALS(IZ),iuout,3,IER)
              else
                call emkgeo(IUF,LTMP,IVALS(IZ),3,IER)
              endif
              QUIET=.TRUE.
              write(outs,'(3a)') ' Updating: ',zn(1:lnblnk(zn)),
     &           ' constructions...'
              CALL USRMSG(' ',outs,'P')
              call tstamp('>','PRJ: auto update zone construction')
              CALL EDCON(0,ITRU,IVALS(IZ),QUIET,IER)
              QUIET=.FALSE.
              write(outs,'(3a)') ' Updating: ',zn(1:lnblnk(zn)),
     &        '... done.'
              CALL USRMSG(' ',outs,'-')
            endif
  96      continue
          MODIFY=.TRUE.
          MODBND=.TRUE.
        elseif(ins9.eq.2)then

C Anchor point substitution.
          AL1=ALOCLBL(1)
          AL2=ALOCLBL(2)
          AL3=ALOCLBL(3)
          AL4=ALOCLBL(4)
          AL5=ALOCLBL(5)
          ltype=1
          CALL easkatog(' Which anchor:',' ',AL1,AL2,AL3,AL4,AL5,
     &      'other anchors','continue',ltype,nbhelp)
          if(ltype.eq.7)then
            call usrmsg('No anchor selected.',' ','W')
            return
          elseif(ltype.eq.6)then
            AL6=ALOCLBL(6)
            AL7=ALOCLBL(7)
            AL8=ALOCLBL(8)
            AL9=ALOCLBL(9)
            ltype=1
            CALL easkatog(' Which anchor:',' ',AL6,AL7,AL8,AL9,
     &        'continue',' ',' ',ltype,nbhelp)
            if(ltype.gt.4)then
              call usrmsg('No anchor selected.',' ','W')
              return
            else
              ltype=ltype+5
            endif
          endif
          CALL EPKMLC(ISELR,'Select a construction to use with this',
     &      'surface list or -Exit',IER)
          if(ISELR.eq.0)return
          dok=.true.
          CALL ASKOK('Apply this construction?',' ',OK,dok,nbhelp)
          IF(.NOT.OK)return
          do 2243 j=1,IALOC(ltype)
            ifoc=lstanchr(ltype,j)
            call CONXMENU(ifoc,CXITM)
            call usrmsg(' Processing...',CXITM,'-')
            iz=ic1(ifoc)
            is=ie1(ifoc)
            icc=izstocn(iz,is)
            LTMP=LGEOM(IZ)
            call georead(IUF,LTMP,IZ,1,iuout,IER)
            WRITE(SSMLCN(icc),'(A12)')DESC(ISELR)(1:12)

C << If newgeometry then can write out the optical property instead
C << of TRAN for SSOTF.
            IF(DESC(ISELR)(15:18).NE.'OPAQ')SSOTF(icc)='TRAN'
            IF(DESC(ISELR)(15:18).EQ.'OPAQ')SSOTF(icc)='OPAQUE'
            IF(DESC(ISELR)(15:18).EQ.'CFC ')SSOTF(icc)='CFC '
            call eclose(gversion(IZ),1.1,0.01,newgeo)
            if(igupgrade.eq.2.and.(.NOT.newgeo))then
              gversion(iz) =1.1
              newgeo = .true.
            endif
            if(newgeo)then
              call geowrite(IUF,LTMP,IZ,iuout,3,IER)
            else
              call emkgeo(IUF,LTMP,IZ,3,IER)
            endif
 2243     continue
          QUIET=.FALSE.
          dok=.true.
          CALL ASKOK(
     &      'All construction & related files should be updated...',
     &      'Do this now (recommended - see help) ?',QUIET,dok,nbhelp)
          if(.NOT.QUIET)return
          call tstamp('>','PRJ: auto update zone construction')
          DO 2492,IZ=1,NCOMP
            CALL EDCON(0,ITRU,IZ,QUIET,IER)
 2492     CONTINUE
          QUIET=.FALSE.
        endif
      elseif(act.eq.'a')then
        helptopic='search_constructions'
        call gethelptext(helpinsub,helptopic,nbhelp)
        CALL PHELPD('global attributions',nbhelp,'-',0,0,IER)

        CALL EPKMLC(ISEL,'Select construction for matching surfaces',
     &    'or -Exit',IER)
        if(ISEL.eq.0)return

        CALL EASKABCD(' First filter--surface opacity:',' ',
     &    'opaque','transparent','both','cancel',ins1,nbhelp)
        if(ins1.eq.4)return

        ins2=1
        call EASKATOG(' Second filter--surface contiguity:',' ',
     &      'external','similar','constant','partitions','ground',
     &      'adiabatic','cancel',ins2,nbhelp)
        if(ins2.eq.7)then
          return
        endif

        ins3=1
        call EASKATOG(' Third filter--surface orientation:',' ',
     &      'vertical','sloped','horizontal up','horizontal down',
     &      'any horizontal','any orien.','cancel',ins3,nbhelp)
        if(ins3.eq.7)then
          return
        endif

        CALL EASKABCD(' Surfaces to update:',' ',
     &    'those already attributed','those marked UNKNOWN','both',
     &    'cancel',ins4,nbhelp)
        if(ins4.eq.4)then
          return
        endif

        INPIC=NCOMP
        CALL EPICKS(INPIC,IVALS,' ',' Which zones to update: ',
     &      12,NCOMP,zname,' zone list',IER,nbhelp)
        IF(INPIC.EQ.0)return
        call tstamp('>','PRJ: global construction attribution')
        DO 95 IZ=1,INPIC
          IF(IVALS(IZ).GT.0)THEN
            write(zn,'(A)') zname(IVALS(IZ))
            write(outs,'(3a)') ' Updating: ',zn(1:lnblnk(zn)),
     &         '...'
            CALL USRMSG(' ',outs,'-')
            LTMP=LGEOM(IVALS(IZ))
            call georead(IUF,LTMP,IVALS(IZ),1,iuout,IER)

            WRITE(outs,93)
   93     FORMAT('           Sur|  Area  |Azim|Elev| surface    |',
     &        'geometry| multilayer  |environment')
            call edisp(iuout,outs)
            WRITE(outs,94)
   94     FORMAT('              |  m^2   |deg |deg | name       |',
     &        'type|loc| constr name |other side ')
            call edisp(iuout,outs)
            do 11 i=1,nsur
              icc=izstocn(ivals(iz),i)
              apply=.true.
              if(ins1.eq.1.and.SSOTF(icc)(1:4).ne.'OPAQ'.and.
     &            SSOTF(icc)(1:4).ne.'CFC ')apply=.false.
              if(ins1.eq.2.and.SSOTF(icc)(1:4).eq.'OPAQ')apply=.false.

C Determine the match in the system topology. 
              CALL SURADJ(IVALS(IZ),I,IE,TMP,IZC,ISC,IC,DESCRC)
              if(ins2.eq.1.and.IE.ne.0)then
                apply=.false.
              elseif(ins2.eq.2.and.IE.ne.1)then
                apply=.false.
              elseif(ins2.eq.3.and.IE.ne.2)then
                apply=.false.
              elseif(ins2.eq.4.and.IE.ne.3)then
                apply=.false.
              elseif(ins2.eq.5.and.IE.ne.4)then
                apply=.false.
              elseif(ins2.eq.6.and.IE.ne.5)then
                apply=.false.
              endif

C Orientation check.
C 'vertical','sloped','horizontal up','horizontal down',
C 'any horizontal','any orien.','cancel'.
              if(ins3.eq.1.and.SSVFC(icc)(1:4).ne.'VERT')then
                apply=.false.
              elseif(ins3.eq.2.and.SSVFC(icc)(1:4).ne.'SLOP')then
                apply=.false.
              elseif(ins3.eq.3.and.SSVFC(icc)(1:4).ne.'CEIL')then
                apply=.false.
              elseif(ins3.eq.4.and.SSVFC(icc)(1:4).ne.'FLOR')then
                apply=.false.
              elseif((ins3.eq.5.and.SSVFC(icc)(1:4).eq.'FLOR').or.
     &               (ins3.eq.5.and.SSVFC(icc)(1:4).eq.'CEIL'))then
                continue
              elseif(ins3.eq.6)then
                continue
              endif

              if(ins4.eq.2.and.SSMLCN(icc)(1:4).ne.'UNKN')apply=.false.

              if(apply)then
                write(sn,'(a)') SSNAME(icc)
                WRITE(outs,'(a7,I3,1X,F7.2,F5.0,F5.0,1X,A12,1X,A4,
     &            1X,A4,1X,A12,1X,A13)')'Match: ',I,SSNA(icc),
     &            SSPAZI(icc),SSPELV(icc),SN,SSOTF(icc)(1:4),
     &            SSVFC(icc),SSMLCN(icc)(1:12),SSOTHER(icc,1)(1:13)
                call edisp(iuout,outs)
                write(outs,'(5a)') ' Apply construction to ',
     &            zn(1:lnblnk(zn)),':',sn(1:lnblnk(sn)),'?'
                dok=.true.
                CALL ASKOK(' ',outs,OK,dok,nbhelp)
                IF(OK)then
                  ioc=IZSTOCN(IVALS(IZ),i)
                  WRITE(SSMLCN(ioc),'(A12)')DESC(ISEL)(1:12)
                  IF(DESC(ISEL)(15:18).NE.'OPAQ')SSOTF(ioc)='TRAN'
                  IF(DESC(ISEL)(15:18).EQ.'OPAQ')SSOTF(ioc)='OPAQ'
                  IF(DESC(ISEL)(15:18).EQ.'CFC ')SSOTF(ioc)='CFC '
                endif
              endif
 11         continue
            call eclose(gversion(IVALS(IZ)),1.1,0.01,newgeo)
            if(igupgrade.eq.2.and.(.NOT.newgeo))then
              gversion(IVALS(IZ)) =1.1
              newgeo = .true.
            endif
            if(newgeo)then
              call geowrite(IUF,LTMP,IVALS(IZ),ITRU,3,IER)
            else
              call emkgeo(IUF,LTMP,IVALS(IZ),3,IER)
            endif
            QUIET=.TRUE.
            write(outs,'(3a)') ' Updating: ',zn(1:lnblnk(zn)),
     &         'constructions...'
            CALL USRMSG(' ',outs,'P')
            call tstamp('>','PRJ: auto update zone construction')
            CALL EDCON(0,ITRU,IVALS(IZ),QUIET,IER)
            QUIET=.FALSE.
            write(outs,'(3a)') ' Updating: ',zn(1:lnblnk(zn)),
     &        '... done.'
            CALL USRMSG(' ',outs,'-')
          endif
  95    continue
        MODIFY=.TRUE.
        MODBND=.TRUE.
      else
        call usrmsg('Unknown action...returning. ',' ','P')
      endif
      return

      end

C This file is part of the ESP-r system.
C Copyright Energy Systems Research Unit, University of
C Strathclyde, Glasgow Scotland, 2001.

C ESP-r is free software.  You can redistribute it and/or
C modify it under the terms of the GNU General Public
C License as published by the Free Software Foundation 
C (version 2 orlater).

C ESP-r is distributed in the hope that it will be useful
C but WITHOUT ANY WARRANTY; without even the implied
C warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
C PURPOSE. See the GNU General Public License for more
C details.

C You should have received a copy of the GNU General Public
C License along with ESP-r. If not, write to the Free
C Software Foundation, Inc., 59 Temple Place, Suite 330,
C Boston, MA 02111-1307 USA.

C **************** ARROW ****************
C ARROW draws an arrow between two points with a directional head.
C The arrow goes from P to Q, and the point is centered round 
C point A. al is arrow length, aw is arrow width. 
C If act = 'r' then arrow size relative to length of line, 
C if act = 'a' then absolute dimensions. 
C Returns the corner points of the arrow as pixel locations in 'ipoints'.
C IDRAW=0 don't draw; =1 shaft single line thickness; =2 shaft double line thickness.

      SUBROUTINE ARROW(P,Q,al,aw,ipoints,act,IDRAW)

C      COMMON/OUTIN/IUOUT,IUIN
      COMMON/DRWMAT/TEMAT(4,4), TSMAT(4,4),
     &              ETMMAT(4,4), ETSMAT(4,4), TBOX(3,2)
      DIMENSION P(3),Q(3),SNORM(3),A(3),PLANE(4),CORNER(4,3)
      DIMENSION VEC(3),VECC(3),COG1(3),COG2(3),COG3(3),ipoints(6,2)
      character act*1
C     character outs*124

C Calculate the vector between P and Q.
      do 10 I=1,3
        SNORM(I)=Q(I)-P(I)
 10   continue

C Calculate the location of point A.  If relative, scale snorm.
C If absolute distance back from Q, find whole length and then
C work backwards using ratio. If P and Q are the same then
C DIST is going to be zero and in that case and the case of
C a very small DIST just return without attempting to draw it.
      DIST= (P(1)-Q(1))**2 + (P(2)-Q(2))**2 + (P(3)-Q(3))**2
      DIST= sqrt(DIST)
      if(DIST.lt.0.0001) return   ! if zero length line.
      if(act(1:1).eq.'r')then
        do 20 I=1,3
          A(I)=P(I)+((1.0-al)*SNORM(I))
 20     continue
      else if(act(1:1).eq.'a')then
        r2 = DIST - al
        r1 = al
        a(1) = ((r2 * q(1)) + (r1 * p(1)))/DIST
        a(2) = ((r2 * q(2)) + (r1 * p(2)))/DIST
        a(3) = ((r2 * q(3)) + (r1 * p(3)))/DIST
      endif

C debug...
C      write(outs,'(a,4f10.4)')'Point is at X,Y,Z:',a(1),a(2),a(3),DIST
C      call edisp(iuout,outs)

C Generate the coefficients for the plane through A with normal NORM.
      PLANE(1)=SNORM(1)
      PLANE(2)=SNORM(2)
      PLANE(3)=SNORM(3)
      PLANE(4)=-1.*((SNORM(1)*A(1))+(SNORM(2)*A(2))+(SNORM(3)*A(3)))

C Find axis which is 'most perpendicular' to plane and the
C smallest coefficient in the vector NORM.
      AXLEN=0.
      IAXIS=0
      do 40 J=1,3
        XX=abs(snorm(j))
        if (XX.gt.AXLEN) then
          AXLEN=XX
          IAXIS=J
        endif
 40   continue
      if (IAXIS.eq.0) goto 9999

C Find first point on the plane, CORNER(1,*).  First set all coords to 
C zero then calculate where the chosen axis intersects.
      CORNER(1,1)=0.
      CORNER(1,2)=0.
      CORNER(1,3)=0.
      CORNER(1,IAXIS)=-1.*PLANE(4)/PLANE(IAXIS)

C Calculate the direction vector from A to the first corner.
      do 50 I=1,3
        VEC(I)=CORNER(1,I)-A(I)
 50   continue

C Scale vector and move CORNER(1,*)
      DISTVEC=0.
      do 60 I=1,3
        DISTVEC=DISTVEC+VEC(I)*VEC(I)
 60   continue
      DISTVEC=SQRT(DISTVEC)
      if(DISTVEC.lt.0.0001) return   ! if zero length line.
      if(act(1:1).eq.'r')then
        SF=(DIST*aw)/DISTVEC
      elseif(act(1:1).eq.'a')then
        SF=(aw)/DISTVEC
      endif
      do 70 I=1,3
        CORNER(1,I)=A(I)+(VEC(I)*SF)

C Corner 3 is a 180deg rotation.
        CORNER(3,I)=A(I)-(VEC(I)*SF)
 70   continue

C Calculate cross product to find corners 2 and 4.
      VECC(1)=0.0
      VECC(2)=0.0
      VECC(3)=0.0
      VECC(1)=SNORM(2)*VEC(3)-SNORM(3)*VEC(2)
      VECC(2)=SNORM(3)*VEC(1)-SNORM(1)*VEC(3)
      VECC(3)=SNORM(1)*VEC(2)-SNORM(2)*VEC(1)
      DISTVEC=0.
      do 61 I=1,3
        DISTVEC=DISTVEC+VECC(I)*VECC(I)
 61   continue
      DISTVEC=SQRT(DISTVEC)
      if(DISTVEC.lt.0.0001) return   ! if zero length line.
      if(act(1:1).eq.'r')then
        SF=(DIST*aw)/DISTVEC
      elseif(act(1:1).eq.'a')then
        SF=(aw)/DISTVEC
      endif
      do 71 I=1,3
        CORNER(2,I)=A(I)+(VECC(I)*SF)

C Corner 3 is a 180deg rotation.
        CORNER(4,I)=A(I)-(VECC(I)*SF)
 71   continue

C debug...
C      write(6,*) 'Pln eq ',Plane
C      write(6,*) 'Axlen  & dist & SF iaxis ',AXLEN,DIST,SF,IAXIS
C Draw the damn thing!
      CALL VECTRN(P,TEMAT,COG2,IER)
      CALL VECTRN(COG2,ETSMAT,COG3,IER)
      call u2pixel(COG3(1),COG3(2),ixp,iyp)
      CALL VECTRN(Q,TEMAT,COG2,IER)
      CALL VECTRN(COG2,ETSMAT,COG3,IER)
      call u2pixel(COG3(1),COG3(2),ixq,iyq)
      CALL VECTRN(A,TEMAT,COG2,IER)
      CALL VECTRN(COG2,ETSMAT,COG3,IER)
      call u2pixel(COG3(1),COG3(2),ixa,iya)
      COG1(1)=corner(1,1)
      COG1(2)=corner(1,2)
      COG1(3)=corner(1,3)
      CALL VECTRN(COG1,TEMAT,COG2,IER)
      CALL VECTRN(COG2,ETSMAT,COG3,IER)
      call u2pixel(COG3(1),COG3(2),ixc1,iyc1)
      COG1(1)=corner(2,1)
      COG1(2)=corner(2,2)
      COG1(3)=corner(2,3)
      CALL VECTRN(COG1,TEMAT,COG2,IER)
      CALL VECTRN(COG2,ETSMAT,COG3,IER)
      call u2pixel(COG3(1),COG3(2),ixc2,iyc2)
      COG1(1)=corner(3,1)
      COG1(2)=corner(3,2)
      COG1(3)=corner(3,3)
      CALL VECTRN(COG1,TEMAT,COG2,IER)
      CALL VECTRN(COG2,ETSMAT,COG3,IER)
      call u2pixel(COG3(1),COG3(2),ixc3,iyc3)
      COG1(1)=corner(4,1)
      COG1(2)=corner(4,2)
      COG1(3)=corner(4,3)
      CALL VECTRN(COG1,TEMAT,COG2,IER)
      CALL VECTRN(COG2,ETSMAT,COG3,IER)
      call u2pixel(COG3(1),COG3(2),ixc4,iyc4)

C Draw the arrow. (IDRAW determines shaft width).
      if (IDRAW.gt.0) then
        if (IDRAW.eq.1) call eswline(ixp,iyp,ixq,iyq)
        if (IDRAW.eq.2) call edwline(ixp,iyp,ixq,iyq)
        call eswline(ixc1,iyc1,ixc2,iyc2)
        call eswline(ixc2,iyc2,ixc3,iyc3)
        call eswline(ixc3,iyc3,ixc4,iyc4)
        call eswline(ixc4,iyc4,ixc1,iyc1)
        call eswline(ixc1,iyc1,ixq,iyq)
        call eswline(ixc2,iyc2,ixq,iyq)
        call eswline(ixc3,iyc3,ixq,iyq)
        call eswline(ixc4,iyc4,ixq,iyq)
      endif
      call forceflush()

C Copy pixel locations to ipoints.
      ipoints(1,1)=ixp
      ipoints(1,2)=iyp
      ipoints(2,1)=ixq
      ipoints(2,2)=iyq
      ipoints(3,1)=ixc1
      ipoints(3,2)=iyc1
      ipoints(4,1)=ixc2
      ipoints(4,2)=iyc2
      ipoints(5,1)=ixc3
      ipoints(5,2)=iyc3
      ipoints(6,1)=ixc4
      ipoints(6,2)=iyc4

      RETURN

 9999 write (6,*) 'Error: cannot find smallest coefficient in vector.'
      return
      end
